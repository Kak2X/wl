;
; BANK $1E - Bonus Games
;
OBJLst_HeartBonus_MenuCursor: INCBIN "data/objlst/heartbonus/menucursor.bin"
OBJLst_HeartBonus_ResultFlash: INCBIN "data/objlst/heartbonus/resultflash.bin"
OBJLst_HeartBonus_BombIcon: INCBIN "data/objlst/heartbonus/bombicon.bin"
OBJLst_HeartBonus_BombIconHit: INCBIN "data/objlst/heartbonus/bombiconhit.bin"
OBJLst_HeartBonus_BombIconMiss: INCBIN "data/objlst/heartbonus/bombiconmiss.bin"
OBJLst_HeartBonus_TextReady: INCBIN "data/objlst/heartbonus/textready.bin"
OBJLst_HeartBonus_TextGo: INCBIN "data/objlst/heartbonus/textgo.bin"
OBJLst_HeartBonus_PowerBarCursorOBJ: INCBIN "data/objlst/heartbonus/powerbarcursorobj.bin"
OBJLst_HeartBonus_BombLight0: INCBIN "data/objlst/heartbonus/bomblight0.bin"
OBJLst_HeartBonus_BombLight1: INCBIN "data/objlst/heartbonus/bomblight1.bin"
OBJLst_HeartBonus_Digit0: INCBIN "data/objlst/heartbonus/digit0.bin"
OBJLst_HeartBonus_Digit1: INCBIN "data/objlst/heartbonus/digit1.bin"
OBJLst_HeartBonus_Digit2: INCBIN "data/objlst/heartbonus/digit2.bin"
OBJLst_HeartBonus_Digit3: INCBIN "data/objlst/heartbonus/digit3.bin"
OBJLst_HeartBonus_Digit4: INCBIN "data/objlst/heartbonus/digit4.bin"
OBJLst_HeartBonus_Digit5: INCBIN "data/objlst/heartbonus/digit5.bin"
OBJLst_HeartBonus_Digit6: INCBIN "data/objlst/heartbonus/digit6.bin"
OBJLst_HeartBonus_Digit7: INCBIN "data/objlst/heartbonus/digit7.bin"
OBJLst_HeartBonus_Digit8: INCBIN "data/objlst/heartbonus/digit8.bin"
OBJLst_HeartBonus_Digit9: INCBIN "data/objlst/heartbonus/digit9.bin"
OBJLst_HeartBonus_Bomb0: INCBIN "data/objlst/heartbonus/bomb0.bin"
OBJLst_HeartBonus_Bomb1: INCBIN "data/objlst/heartbonus/bomb1.bin"
OBJLst_HeartBonus_Unused_BombExpl0: INCBIN "data/objlst/heartbonus/unused_bombexpl0.bin"
OBJLst_HeartBonus_BombExpl1: INCBIN "data/objlst/heartbonus/bombexpl1.bin"
OBJLst_HeartBonus_BombExpl2: INCBIN "data/objlst/heartbonus/bombexpl2.bin"
OBJLst_HeartBonus_BombExpl3: INCBIN "data/objlst/heartbonus/bombexpl3.bin"
OBJLst_HeartBonus_Goom_WalkL0: INCBIN "data/objlst/heartbonus/goom_walkl0.bin"
OBJLst_HeartBonus_Goom_WalkL1: INCBIN "data/objlst/heartbonus/goom_walkl1.bin"
OBJLst_HeartBonus_Goom_WalkL1_Body: INCBIN "data/objlst/heartbonus/goom_walkl1_body.bin"
OBJLst_HeartBonus_Goom_WalkL2_Feet: INCBIN "data/objlst/heartbonus/goom_walkl2_feet.bin"
OBJLst_HeartBonus_Goom_HitL: INCBIN "data/objlst/heartbonus/goom_hitl.bin"
OBJLst_HeartBonus_Goom_WalkR0: INCBIN "data/objlst/heartbonus/goom_walkr0.bin"
OBJLst_HeartBonus_Goom_WalkR1: INCBIN "data/objlst/heartbonus/goom_walkr1.bin"
OBJLst_HeartBonus_Goom_WalkR1_Body: INCBIN "data/objlst/heartbonus/goom_walkr1_body.bin"
OBJLst_HeartBonus_Goom_WalkR2_Feet: INCBIN "data/objlst/heartbonus/goom_walkr2_feet.bin"
OBJLst_HeartBonus_Goom_HitR: INCBIN "data/objlst/heartbonus/goom_hitr.bin"
OBJLst_HeartBonus_Duck_WalkL0: INCBIN "data/objlst/heartbonus/duck_walkl0.bin"
OBJLst_HeartBonus_Duck_WalkL1: INCBIN "data/objlst/heartbonus/duck_walkl1.bin"
OBJLst_HeartBonus_Duck_WalkL1_Body: INCBIN "data/objlst/heartbonus/duck_walkl1_body.bin"
OBJLst_HeartBonus_Duck_HitL: INCBIN "data/objlst/heartbonus/duck_hitl.bin"
OBJLst_HeartBonus_Duck_WalkL2_Feet: INCBIN "data/objlst/heartbonus/duck_walkl2_feet.bin"
OBJLst_HeartBonus_Duck_WalkR0: INCBIN "data/objlst/heartbonus/duck_walkr0.bin"
OBJLst_HeartBonus_Duck_WalkR1: INCBIN "data/objlst/heartbonus/duck_walkr1.bin"
OBJLst_HeartBonus_Duck_WalkR1_Body: INCBIN "data/objlst/heartbonus/duck_walkr1_body.bin"
OBJLst_HeartBonus_Duck_HitR: INCBIN "data/objlst/heartbonus/duck_hitr.bin"
OBJLst_HeartBonus_Duck_WalkR2_Feet: INCBIN "data/objlst/heartbonus/duck_walkr2_feet.bin"
OBJLst_HeartBonus_Mole_WalkL0: INCBIN "data/objlst/heartbonus/mole_walkl0.bin"
OBJLst_HeartBonus_Mole_WalkL1: INCBIN "data/objlst/heartbonus/mole_walkl1.bin"
OBJLst_HeartBonus_Mole_WalkL2_Body: INCBIN "data/objlst/heartbonus/mole_walkl2_body.bin"
OBJLst_HeartBonus_Mole_WalkL2_Feet: INCBIN "data/objlst/heartbonus/mole_walkl2_feet.bin"
OBJLst_HeartBonus_Mole_HitL: INCBIN "data/objlst/heartbonus/mole_hitl.bin"
OBJLst_HeartBonus_Mole_WalkR0: INCBIN "data/objlst/heartbonus/mole_walkr0.bin"
OBJLst_HeartBonus_Mole_WalkR1: INCBIN "data/objlst/heartbonus/mole_walkr1.bin"
OBJLst_HeartBonus_Mole_WalkR1_Body: INCBIN "data/objlst/heartbonus/mole_walkr1_body.bin"
OBJLst_HeartBonus_Mole_WalkR2_Feet: INCBIN "data/objlst/heartbonus/mole_walkr2_feet.bin"
OBJLst_HeartBonus_Mole_HitR: INCBIN "data/objlst/heartbonus/mole_hitr.bin"
OBJLst_CoinBonus_Item_10Ton: INCBIN "data/objlst/coinbonus/item_10ton.bin"
OBJLst_CoinBonus_Item_MoneyBag: INCBIN "data/objlst/coinbonus/item_moneybag.bin"
OBJLst_CoinBonus_Digit0: INCBIN "data/objlst/coinbonus/digit0.bin"
OBJLst_CoinBonus_Digit1: INCBIN "data/objlst/coinbonus/digit1.bin"
OBJLst_CoinBonus_Digit2: INCBIN "data/objlst/coinbonus/digit2.bin"
OBJLst_CoinBonus_Digit3: INCBIN "data/objlst/coinbonus/digit3.bin"
OBJLst_CoinBonus_Digit4: INCBIN "data/objlst/coinbonus/digit4.bin"
OBJLst_CoinBonus_Digit5: INCBIN "data/objlst/coinbonus/digit5.bin"
OBJLst_CoinBonus_Digit6: INCBIN "data/objlst/coinbonus/digit6.bin"
OBJLst_CoinBonus_Digit7: INCBIN "data/objlst/coinbonus/digit7.bin"
OBJLst_CoinBonus_Digit8: INCBIN "data/objlst/coinbonus/digit8.bin"
OBJLst_CoinBonus_Digit9: INCBIN "data/objlst/coinbonus/digit9.bin"

; =============== HeartBonus_WriteOBJ ===============
; Writes all OBJLst for the hearts bonus game to OAM.
HeartBonus_WriteOBJ:
	xor  a
	ld   [wStaticOBJCount], a
	ld   b, a
	call HomeCall_Static_WriteWarioOBJLst
	call HeartBonus_WriteMenuCursorOBJ
	call HeartBonus_WriteResultFlashOBJ
	call HeartBonus_WriteHudBomb0OBJ
	call HeartBonus_WriteHudBomb1OBJ
	call HeartBonus_WriteHudBomb2OBJ
	call HeartBonus_WriteHudBomb3OBJ
	call HeartBonus_WriteHudBomb4OBJ
	call HeartBonus_WritePowerBarCursorOBJ
	call HeartBonus_WriteTimeDigitOBJ
	call HeartBonus_WriteTextOBJ
	call HeartBonus_WriteBombLightOBJ
	call HeartBonus_WriteBombOBJ
	call HeartBonus_WriteEnemyOBJ
	call HeartBonus_WriteCoinDigitsOBJHigh
	call HeartBonus_WriteLivesHeartsDigitsOBJ
	jp   Static_FinalizeWorkOAM
	
; =============== HeartBonus_WriteMenuCursorOBJ ===============
; Writes the cursor shown in the difficulty selection screen.
HeartBonus_WriteMenuCursorOBJ:
	; If it's disabled, don't show it
	ld   a, [wHeartBonusShowCursor]
	cp   a, $00
	ret  z
	
	; Fixed X location, on the left of the text
	ld   a, $1C
	ld   [sOAMWriteX], a
	
	; Pick a different Y location depending on the selected option
	ld   a, [wHeartBonusDifficultySel]
	cp   a, HEARTBONUS_SEL_MED
	jr   z, .medium
	cp   a, HEARTBONUS_SEL_EASY
	jr   z, .easy
	cp   a, HEARTBONUS_SEL_EXIT
	jr   z, .exit_
.hard:
	ld   a, $26
	jr   .setY
.medium:
	ld   a, $36
	jr   .setY
.easy:
	ld   a, $46
	jr   .setY
.exit_:
	ld   a, $59
.setY:
	ld   [sOAMWriteY], a
	
	ld   de, OBJLst_HeartBonus_MenuCursor
	jp   Static_WriteOBJLst
	
; =============== HeartBonus_WriteResultFlashOBJ ===============
; Writes the black line shown to highlight the won prize in the result screen.
; This line is meant to be enabled and disabled every few frames for a
; pseudo-transparency (more or less) effect.
HeartBonus_WriteResultFlashOBJ:
	; If it's disabled, don't show it
	ld   a, [wHeartBonusShowResultFlash]
	cp   a, $00
	ret  z
	
	ld   a, $30
	ld   [sOAMWriteX], a
	; Determine Y location of where to draw the flashing result line.
	; Higher the hit count, the higher up the line gets drawn.
	ld   a, [wHeartBonusHitCount]
	rst  $28
	dw BonusGame_NoFrame
	dw .hit1
	dw .hit2
	dw .hit3
	dw .hit4
	dw .hit5
.hit1:
	ld   a, $5F
	jr   .setY
.hit2:
	ld   a, $4F
	jr   .setY
.hit3:
	ld   a, $3F
	jr   .setY
.hit4:
	ld   a, $2F
	jr   .setY
.hit5:
	ld   a, $1F
.setY:
	ld   [sOAMWriteY], a
	ld   de, OBJLst_HeartBonus_ResultFlash
	jp   Static_WriteOBJLst
	
; =============== HeartBonus_WriteHudBomb*OBJ ===============
; Sets of subroutine for writing the bomb icons in the HUD,
; which mark if a bomb is yet to be thrown, missed or hit the target.

HeartBonus_WriteHudBomb0OBJ:
	ld   a, [wHeartBonusHudBomb0LstId]
	ld   [wHeartBonusHudBombLstId], a
	ld   a, $58
	jr   HeartBonus_WriteHudBombOBJ
HeartBonus_WriteHudBomb1OBJ:
	ld   a, [wHeartBonusHudBomb1LstId]
	ld   [wHeartBonusHudBombLstId], a
	ld   a, $60
	jr   HeartBonus_WriteHudBombOBJ
HeartBonus_WriteHudBomb2OBJ:
	ld   a, [wHeartBonusHudBomb2LstId]
	ld   [wHeartBonusHudBombLstId], a
	ld   a, $68
	jr   HeartBonus_WriteHudBombOBJ
HeartBonus_WriteHudBomb3OBJ:
	ld   a, [wHeartBonusHudBomb3LstId]
	ld   [wHeartBonusHudBombLstId], a
	ld   a, $70
	jr   HeartBonus_WriteHudBombOBJ
HeartBonus_WriteHudBomb4OBJ:
	ld   a, [wHeartBonusHudBomb4LstId]
	ld   [wHeartBonusHudBombLstId], a
	ld   a, $78
	
; =============== HeartBonus_WriteHudBombOBJ ===============
; Writes the specified bomb icon for the HUD.
; IN
; - A: X position of the icon
; - wHeartBonusHudBombLstId: OBJLst frame for the bomb
HeartBonus_WriteHudBombOBJ:
	ld   [sOAMWriteX], a
	ld   a, $94							; Fixed Y loc
	ld   [sOAMWriteY], a
	
	; Pick the frame
	ld   a, [wHeartBonusHudBombLstId]
	rst  $28
	dw BonusGame_NoFrame
	dw .bomb
	dw .hit
	dw .miss
.bomb:
	ld   de, OBJLst_HeartBonus_BombIcon
	jp   Static_WriteOBJLst
.hit:
	ld   de, OBJLst_HeartBonus_BombIconHit
	jp   Static_WriteOBJLst
.miss:
	ld   de, OBJLst_HeartBonus_BombIconMiss
	jp   Static_WriteOBJLst
	
; =============== HeartBonus_WritePowerBarCursorOBJ ===============
; Writes the cursor (down arrow) marking the throw power in the HUD.
HeartBonus_WritePowerBarCursorOBJ:
	; If it's disabled, don't show it
	ld   a, [wHeartBonusShowPowerSel]
	cp   a, $00
	ret  z
	
	ld   a, [wHeartBonusPowerSelX]
	ld   [sOAMWriteX], a
	ld   a, $90
	ld   [sOAMWriteY], a
	ld   de, OBJLst_HeartBonus_PowerBarCursorOBJ
	jp   Static_WriteOBJLst
	
; =============== HeartBonus_WriteLivesHeartsDigitsOBJ ===============
; Writes the digits for the amount of lives and hearts in the HUD for
; the result screen.
;
; NOTE: This reuses wHeartBonusTime for wHeartBonusDigitLstId
HeartBonus_WriteLivesHeartsDigitsOBJ:
	; If it's disabled, don't show it
	ld   a, [wHeartBonusShowHudLivesHearts]
	cp   a, $00
	ret  z
	
	; Each digits is its own set of sprites.
	call HeartBonus_WriteLivesDigitOBJHigh
	call HeartBonus_WriteLivesDigitOBJLow
	call HeartBonus_WriteHeartsDigitOBJHigh
	jr   HeartBonus_WriteHeartsDigitOBJLow
	
; =============== HeartBonus_WriteLivesDigitOBJHigh ===============
; Writes the tens digit of the lives counter.
HeartBonus_WriteLivesDigitOBJHigh:
	ld   a, $42+(TILE_H*0)
	ld   [sOAMWriteX], a
	ld   a, $8F
	ld   [sOAMWriteY], a
	
	; Digit = sLives >> 4
	ld   a, [sLives]
	and  a, $F0
	swap a
	ld   [wHeartBonusDigitLstId], a
	jr   HeartBonus_WriteDigitOBJ
	
; =============== HeartBonus_WriteLivesDigitOBJLow ===============
; Writes the low digit of the lives counter.
HeartBonus_WriteLivesDigitOBJLow:
	ld   a, $42+(TILE_H*1)
	ld   [sOAMWriteX], a
	; Keep the Y pos we set in HeartBonus_WriteLivesDigitOBJHigh
	
	; Digit = sLives & $0F
	ld   a, [sLives]
	and  a, $0F
	ld   [wHeartBonusTime], a
	jr   HeartBonus_WriteDigitOBJ
	
; =============== HeartBonus_WriteHeartsDigitOBJHigh ===============
; Writes the tens digit of the hearts counter.
HeartBonus_WriteHeartsDigitOBJHigh:
	ld   a, $7A+(TILE_H*0)
	ld   [sOAMWriteX], a
	; Keep the Y pos we set in HeartBonus_WriteLivesDigitOBJHigh
	
	; Digit = sHearts >> 4
	ld   a, [sHearts]
	and  a, $F0
	swap a
	ld   [wHeartBonusTime], a
	jr   HeartBonus_WriteDigitOBJ
	
; =============== HeartBonus_WriteHeartsDigitOBJLow ===============
; Writes the low digit of the hearts counter.
HeartBonus_WriteHeartsDigitOBJLow:
	ld   a, $7A+(TILE_H*1)
	ld   [sOAMWriteX], a
	
	; Digit = sHearts & $0F
	ld   a, [sHearts]
	and  a, $0F
	ld   [wHeartBonusTime], a
	jr   HeartBonus_WriteDigitOBJ
	
; =============== HeartBonus_WriteCoinDigitsOBJHigh ===============
; Writes all three digits of the count count, as shown in the difficulty
; selection screen.
HeartBonus_WriteCoinDigitsOBJHigh:
	; If it's disabled, don't show it
	ld   a, [wHeartBonusShowCoinCount]
	cp   a, $00
	ret  z
	
	call HeartBonus_WriteCoinDigitOBJHigh
	call HeartBonus_WriteCoinDigitOBJMid
	jr   HeartBonus_WriteCoinDigitOBJLow
	
; =============== HeartBonus_WriteCoinDigitOBJHigh ===============
; Writes the hundreds digit of the coin count.
HeartBonus_WriteCoinDigitOBJHigh:
	ld   a, $68+(TILE_H*0)
	ld   [sOAMWriteX], a
	ld   a, $58
	ld   [sOAMWriteY], a
	; Digit = sLevelCoins_High
	ld   a, [sLevelCoins_High]
	jr   HeartBonus_WriteDigitOBJ
	
; =============== HeartBonus_WriteCoinDigitOBJMid ===============
; Writes the tens digit of the coin count.
HeartBonus_WriteCoinDigitOBJMid:
	ld   a, $68+(TILE_H*1)
	ld   [sOAMWriteX], a
	; Keep the Y pos we set in HeartBonus_WriteCoinDigitOBJHigh
	
	; Digit = sLevelCoins_Low >> 4
	ld   a, [sLevelCoins_Low]
	and  a, $F0
	swap a
	jr   HeartBonus_WriteDigitOBJ
	
; =============== HeartBonus_WriteCoinDigitOBJLow ===============
; Writes the low digit of the coin count.
HeartBonus_WriteCoinDigitOBJLow:
	ld   a, $68+(TILE_H*2)
	ld   [sOAMWriteX], a
	; Keep the Y pos we set in HeartBonus_WriteCoinDigitOBJHigh
	
	; Digit = sLevelCoins_Low & $0F
	ld   a, [sLevelCoins_Low]
	and  a, $0F
	jr   HeartBonus_WriteDigitOBJ
	
; =============== HeartBonus_WriteTimeDigitOBJ ===============
; Writes the time remaining for the round in the HUD.
HeartBonus_WriteTimeDigitOBJ:
	ld   a, [wHeartBonusShowTime]
	cp   a, $00
	ret  z
	
	ld   a, $92
	ld   [sOAMWriteX], a
	ld   a, $91
	ld   [sOAMWriteY], a
	ld   a, [wHeartBonusTime]
	
; =============== HeartBonus_WriteDigitOBJ ===============
; Writes the specified digit to the sOAMWrite location.
; IN
; - A: Digit to write. Must be a valid decimal number in range 
HeartBonus_WriteDigitOBJ:
	rst  $28
	dw .num0
	dw .num1
	dw .num2
	dw .num3
	dw .num4
	dw .num5
	dw .num6
	dw .num7
	dw .num8
	dw .num9
.num0:
	ld   de, OBJLst_HeartBonus_Digit0
	jp   Static_WriteOBJLst
.num1:
	ld   de, OBJLst_HeartBonus_Digit1
	jp   Static_WriteOBJLst
.num2:
	ld   de, OBJLst_HeartBonus_Digit2
	jp   Static_WriteOBJLst
.num3:
	ld   de, OBJLst_HeartBonus_Digit3
	jp   Static_WriteOBJLst
.num4:
	ld   de, OBJLst_HeartBonus_Digit4
	jp   Static_WriteOBJLst
.num5:
	ld   de, OBJLst_HeartBonus_Digit5
	jp   Static_WriteOBJLst
.num6:
	ld   de, OBJLst_HeartBonus_Digit6
	jp   Static_WriteOBJLst
.num7:
	ld   de, OBJLst_HeartBonus_Digit7
	jp   Static_WriteOBJLst
.num8:
	ld   de, OBJLst_HeartBonus_Digit8
	jp   Static_WriteOBJLst
.num9:
	ld   de, OBJLst_HeartBonus_Digit9
	jp   Static_WriteOBJLst
	
	
; =============== HeartBonus_WriteTextOBJ ===============
; Writes the "READY" "GO" text appearing when a round starts.
HeartBonus_WriteTextOBJ:
	ld   a, $1C
	ld   [sOAMWriteY], a
	ld   a, [wHeartBonusTextLstId]
	rst  $28
	dw BonusGame_NoFrame
	dw .ready
	dw .go
.ready:
	ld   a, $40
	ld   [sOAMWriteX], a
	ld   de, OBJLst_HeartBonus_TextReady
	jp   Static_WriteOBJLst
.go:
	ld   a, $4C
	ld   [sOAMWriteX], a
	ld   de, OBJLst_HeartBonus_TextGo
	jp   Static_WriteOBJLst
	
; =============== HeartBonus_WriteBombLightOBJ ===============
; Writes the fire light on the bomb's fuse.
HeartBonus_WriteBombLightOBJ:
	ld   a, [wHeartBonusBombLightX]
	ld   [sOAMWriteX], a
	ld   a, [wHeartBonusBombLightY]
	ld   [sOAMWriteY], a
	ld   a, [wHeartBonusBombLightLstId]
	rst  $28
	dw BonusGame_NoFrame
	dw .frame1
	dw .frame2
.frame1:
	ld   de, OBJLst_HeartBonus_BombLight0
	jp   Static_WriteOBJLst
.frame2:
	ld   de, OBJLst_HeartBonus_BombLight1
	jp   Static_WriteOBJLst
	
; =============== HeartBonus_WriteBombOBJ ===============
; Writes the bomb itself.
HeartBonus_WriteBombOBJ:
	ld   a, [wHeartBonusBombX]
	ld   [sOAMWriteX], a
	ld   a, [wHeartBonusBombY]
	ld   [sOAMWriteY], a
	ld   a, [wHeartBonusBombLstId]
	rst  $28
	dw BonusGame_NoFrame
	dw .bomb0
	dw .bomb1
	dw .unused_bombExpl0;X
	dw .bombExpl1
	dw .bombExpl2
	dw .bombExpl3
.bomb0:
	ld   de, OBJLst_HeartBonus_Bomb0
	jp   Static_WriteOBJLst
.bomb1:
	ld   de, OBJLst_HeartBonus_Bomb1
	jp   Static_WriteOBJLst
; [TCRF] Unused initial frame with a small explosion.
;        It's possible this was left unused by mistake.
.unused_bombExpl0: 
	ld   de, OBJLst_HeartBonus_Unused_BombExpl0
	jp   Static_WriteOBJLst
.bombExpl1:
	ld   de, OBJLst_HeartBonus_BombExpl1
	jp   Static_WriteOBJLst
.bombExpl2:
	ld   de, OBJLst_HeartBonus_BombExpl2
	jp   Static_WriteOBJLst
.bombExpl3:
	ld   de, OBJLst_HeartBonus_BombExpl3
	jp   Static_WriteOBJLst
	
; =============== HeartBonus_WriteEnemyOBJ ===============
; Writes the animation frame for the enemy.
HeartBonus_WriteEnemyOBJ:
	ld   a, [wHeartBonusEnemyX]
	ld   [sOAMWriteX], a
	ld   a, [wHeartBonusEnemyY]
	ld   [sOAMWriteY], a
	;
	; Determine OBJ frames to use depending on difficulty and horz. flip
	;
	ld   a, [wHeartBonusDifficultySel]
	cp   a, HEARTBONUS_SEL_MED			; Medium difficulty?
	jr   z, HeartBonus_WriteDuckOBJ		; If so, use duck
	cp   a, HEARTBONUS_SEL_EASY			; Easy difficulty?
	jp   z, HeartBonus_WriteGoomOBJ		; If so, use goom
										; Otherwise, use mole
										
; =============== HeartBonus_WriteMoleOBJ ===============
HeartBonus_WriteMoleOBJ:
	ld   a, [wHeartBonusEnemyFlags]
	bit  STATIC_OBJLSTB_XFLIP, a		; Facing left?
	jr   z, .right						; If not, jump
	
.left:
	ld   a, [wHeartBonusEnemyLstId]
	rst  $28
	dw BonusGame_NoFrame
	dw .walkL0
	dw .walkL1
	dw .walkL2
	dw .hitL
.walkL0:
	ld   de, OBJLst_HeartBonus_Mole_WalkL0
	jp   Static_WriteOBJLst
.walkL1:
	ld   de, OBJLst_HeartBonus_Mole_WalkL1
	jp   Static_WriteOBJLst
.walkL2:
	ld   de, OBJLst_HeartBonus_Mole_WalkL2_Body
	call Static_WriteOBJLst
	ld   de, OBJLst_HeartBonus_Mole_WalkL2_Feet
	jp   Static_WriteOBJLst
.hitL:
	ld   de, OBJLst_HeartBonus_Mole_HitL
	jp   Static_WriteOBJLst
	
.right:
	ld   a, [wHeartBonusEnemyLstId]
	rst  $28
	dw BonusGame_NoFrame
	dw .walkR0
	dw .walkR1
	dw .walkR2
	dw .hitR
.walkR0:
	ld   de, OBJLst_HeartBonus_Mole_WalkR0
	jp   Static_WriteOBJLst
.walkR1:
	ld   de, OBJLst_HeartBonus_Mole_WalkR1
	jp   Static_WriteOBJLst
.walkR2:
	ld   de, OBJLst_HeartBonus_Mole_WalkR1_Body
	call Static_WriteOBJLst
	ld   de, OBJLst_HeartBonus_Mole_WalkR2_Feet
	jp   Static_WriteOBJLst
.hitR:
	ld   de, OBJLst_HeartBonus_Mole_HitR
	jp   Static_WriteOBJLst
	
; =============== HeartBonus_WriteDuckOBJ ===============
HeartBonus_WriteDuckOBJ:
	ld   a, [wHeartBonusEnemyFlags]
	bit  STATIC_OBJLSTB_XFLIP, a		; Facing left?
	jr   z, .right						; If not, jump

.left:
	ld   a, [wHeartBonusEnemyLstId]
	rst  $28
	dw BonusGame_NoFrame
	dw .walkL0
	dw .walkL1
	dw .walkL2
	dw .hitL
.walkL0:
	ld   de, OBJLst_HeartBonus_Duck_WalkL0
	jp   Static_WriteOBJLst
.walkL1:
	ld   de, OBJLst_HeartBonus_Duck_WalkL1
	jp   Static_WriteOBJLst
.walkL2:
	ld   de, OBJLst_HeartBonus_Duck_WalkL1_Body
	call Static_WriteOBJLst
	ld   de, OBJLst_HeartBonus_Duck_WalkL2_Feet
	jp   Static_WriteOBJLst
.hitL:
	ld   de, OBJLst_HeartBonus_Duck_HitL
	jp   Static_WriteOBJLst
.right:
	ld   a, [wHeartBonusEnemyLstId]
	rst  $28
	dw BonusGame_NoFrame
	dw .walkR0
	dw .walkR1
	dw .walkR2
	dw .hitR
.walkR0:
	ld   de, OBJLst_HeartBonus_Duck_WalkR0
	jp   Static_WriteOBJLst
.walkR1:
	ld   de, OBJLst_HeartBonus_Duck_WalkR1
	jp   Static_WriteOBJLst
.walkR2:
	ld   de, OBJLst_HeartBonus_Duck_WalkR1_Body
	call Static_WriteOBJLst
	ld   de, OBJLst_HeartBonus_Duck_WalkR2_Feet
	jp   Static_WriteOBJLst
.hitR:
	ld   de, OBJLst_HeartBonus_Duck_HitR
	jp   Static_WriteOBJLst

; =============== HeartBonus_WriteGoomOBJ ===============
HeartBonus_WriteGoomOBJ:
	ld   a, [wHeartBonusEnemyFlags]
	bit  STATIC_OBJLSTB_XFLIP, a		; Facing left?
	jr   z, .right						; If not, jump
.left:
	ld   a, [wHeartBonusEnemyLstId]
	rst  $28
	dw BonusGame_NoFrame
	dw .walkL0
	dw .walkL1
	dw .walkL2
	dw .hitL
.walkL0:
	ld   de, OBJLst_HeartBonus_Goom_WalkL0
	jp   Static_WriteOBJLst
.walkL1:
	ld   de, OBJLst_HeartBonus_Goom_WalkL1
	jp   Static_WriteOBJLst
.walkL2:
	ld   de, OBJLst_HeartBonus_Goom_WalkL1_Body
	call Static_WriteOBJLst
	ld   de, OBJLst_HeartBonus_Goom_WalkL2_Feet
	jp   Static_WriteOBJLst
.hitL:
	ld   de, OBJLst_HeartBonus_Goom_HitL
	jp   Static_WriteOBJLst
.right:
	ld   a, [wHeartBonusEnemyLstId]
	rst  $28
	dw BonusGame_NoFrame
	dw .walkR0
	dw .walkR1
	dw .walkR2
	dw .hitR
.walkR0:
	ld   de, OBJLst_HeartBonus_Goom_WalkR0
	jp   Static_WriteOBJLst
.walkR1:
	ld   de, OBJLst_HeartBonus_Goom_WalkR1
	jp   Static_WriteOBJLst
.walkR2:
	ld   de, OBJLst_HeartBonus_Goom_WalkR1_Body
	call Static_WriteOBJLst
	ld   de, OBJLst_HeartBonus_Goom_WalkR2_Feet
	jp   Static_WriteOBJLst
.hitR:
	ld   de, OBJLst_HeartBonus_Goom_HitR
	jp   Static_WriteOBJLst
	
; =============== CoinBonus_WriteOBJ ===============
; Writes all OBJLst for the coin bonus game to OAM.
CoinBonus_WriteOBJ:
	xor  a
	ld   [wStaticOBJCount], a
	ld   b, a
	call HomeCall_Static_WriteWarioOBJLst
	call CoinBonus_WriteDigitOBJHigh
	call CoinBonus_WriteDigitOBJMid
	call CoinBonus_WriteDigitOBJLow
	call CoinBonus_WriteItemOBJ
	jp   Static_FinalizeWorkOAM
; =============== CoinBonus_WriteDigitOBJHigh ===============
; Writes the hundreds digit of the coin count.
CoinBonus_WriteDigitOBJHigh:
	ld   a, $65+(TILE_H*0)		; X pos
	ld   [sOAMWriteX], a
	ld   a, $1C					; Y pos
	ld   [sOAMWriteY], a
	; Already only the low nybble is used
	ld   a, [sLevelCoins_High]	; A = sLevelCoins_High
	jr   CoinBonus_WriteDigitOBJ
; =============== CoinBonus_WriteDigitOBJMid ===============
; Writes the tens digit of the coin count.
CoinBonus_WriteDigitOBJMid:;C
	ld   a, $65+(TILE_H*1)		; 8px to the right
	ld   [sOAMWriteX], a
	; Keep the Y pos we set in CoinBonus_WriteDigitOBJHigh
	ld   a, [sLevelCoins_Low]
	and  a, $F0					; A = sLevelCoins_Low >> 4
	swap a
	jr   CoinBonus_WriteDigitOBJ
; =============== CoinBonus_WriteDigitOBJLow ===============
; Writes the low digit of the coin count.
CoinBonus_WriteDigitOBJLow:
	ld   a, $65+(TILE_H*2)		; 8px to the right again
	ld   [sOAMWriteX], a
	; Keep the Y pos we set in CoinBonus_WriteDigitOBJHigh
	ld   a, [sLevelCoins_Low]
	and  a, $0F					; A = sLevelCoins_Low & $0F
	
; =============== CoinBonus_WriteDigitOBJ ===============
; Writes the specified digit to the sOAMWrite location.
; IN
; - A: Digit to write. Must be a valid decimal number in range $00-$09.
CoinBonus_WriteDigitOBJ:
	rst  $28
	dw .num0
	dw .num1
	dw .num2
	dw .num3
	dw .num4
	dw .num5
	dw .num6
	dw .num7
	dw .num8
	dw .num9
.num0:
	ld   de, OBJLst_CoinBonus_Digit0
	jp   Static_WriteOBJLst
.num1:
	ld   de, OBJLst_CoinBonus_Digit1
	jp   Static_WriteOBJLst
.num2:
	ld   de, OBJLst_CoinBonus_Digit2
	jp   Static_WriteOBJLst
.num3:
	ld   de, OBJLst_CoinBonus_Digit3
	jp   Static_WriteOBJLst
.num4:
	ld   de, OBJLst_CoinBonus_Digit4
	jp   Static_WriteOBJLst
.num5:
	ld   de, OBJLst_CoinBonus_Digit5
	jp   Static_WriteOBJLst
.num6:
	ld   de, OBJLst_CoinBonus_Digit6
	jp   Static_WriteOBJLst
.num7:
	ld   de, OBJLst_CoinBonus_Digit7
	jp   Static_WriteOBJLst
.num8:
	ld   de, OBJLst_CoinBonus_Digit8
	jp   Static_WriteOBJLst
.num9:
	ld   de, OBJLst_CoinBonus_Digit9
	jp   Static_WriteOBJLst
	
; =============== CoinBonus_WriteItemOBJ ===============
; Writes the sprite mappings for the dropped item.
CoinBonus_WriteItemOBJ:
	ld   a, [wCoinBonusItemX]		; Set X pos
	ld   [sOAMWriteX], a
	ld   a, [wCoinBonusItemY]		; Set Y pos
	ld   [sOAMWriteY], a
	; Determine item sprite (or don't draw one if set to $00)
	ld   a, [wCoinBonusItemLstId]
	rst  $28
	dw BonusGame_NoFrame
	dw .x10ton
	dw .moneybag
.x10ton:
	ld   de, OBJLst_CoinBonus_Item_10Ton
	jp   Static_WriteOBJLst
.moneybag:
	ld   de, OBJLst_CoinBonus_Item_MoneyBag
	jp   Static_WriteOBJLst

; =============== Bonus_ScreenEvent_Do ===============
; Handles VBlank screen updates for the bonus games.
; This includes tile animations and tilemap changes.
Bonus_ScreenEvent_Do:
	call HeartBonus_AnimWater
	call CoinBonus_AnimBucket
	jp   CoinBonus_SetRoundNum
; =============== HeartBonus_AnimWater ===============
; Animate the waterline in the hearts bonus game.
; This is similar to what's done to animate the water in the title screen.
; The same as TitleAnimWater except here the water only uses one tile and the animation is slower.
HeartBonus_AnimWater:
	; If tile animations aren't enabled, ignore
	ld   a, [wHeartBonusTileAnim]			
	cp   a, $00					
	ret  z					
	; Update the timer
	ld   a, [wBonusAnimTimer]
	inc  a
	ld   [wBonusAnimTimer], a
	; Set the new frame based off the timer
	cp   a, $1E					
	jr   z, .frame0				
	cp   a, $3C
	jr   z, .frame1
	ret
.frame0:
	ld   hl, vGFXHeartBonusAnimGFX0	; HL = Source
	jr   .vramCopy
.frame1:
	xor  a							; Reset the timer
	ld   [wBonusAnimTimer], a
	ld   hl, vGFXHeartBonusAnimGFX1	; HL = Source
.vramCopy:
	ld   de, vGFXHeartBonusAnim		; DE = Destination
	ld   b, $10						; Copy 1 tile
.loop:
	ldi  a, [hl]
	ld   [de], a
	inc  de
	dec  b
	jr   nz, .loop
	ret
; =============== CoinBonus_AnimBucket ===============
; Animates the bucket shown in the coins bonus game.
; This works through tilemap editing.
;
; A 3x5 area in tilemap is replaced with something determined by the 
; selected bucket (determines the dest tilemap address) and the requested frame.

CoinBonus_AnimBucket:
	; If no change is requested, return
	ld   a, [wCoinBonusBucketFrameSet]
	cp   a, COINBONUS_BUCKET_NOCHANGE
	ret  z
	
	; Determine the frame to use
	; DE = Ptr to BG mappings
	cp   a, COINBONUS_BUCKET_NORMAL
	jr   z, .normalBucket
.pulledBucket:
	ld   de, BG_CoinBonus_BucketPull			; Upside down bucket
	jr   .checkBucketPos
.normalBucket:
	ld   de, BG_CoinBonus_Bucket			; Normal bucket, in the default state 
							; (should be identical to the one in the compressed tilemap)
		
	; Determine the correct location in the tilemap for the bucket we're changing		
	; HL = Ptr to tilemap	
.checkBucketPos:
	ld   a, [wCoinBonusPlayerPos]	
	cp   a, COINBONUS_PLPOS_RIGHT 	; Is the player under the right bucket?
	jr   z, .right					; If so, jump
.left:
	ld   hl, vBGCoinBonusBucketL
	jr   .copyBG
.right:
	ld   hl, vBGCoinBonusBucketR
	
	; Perform the copy
BUCKET_WIDTH  EQU $03
BUCKET_HEIGHT EQU $05
.copyBG:
	ld   a, $0F ; --
	ld   b, BUCKET_HEIGHT	; Height: 5 tiles
.nextY:
	ld   c, BUCKET_WIDTH	; Width: 3 tiles
.nextX:
	; Copy the tile ID over
	ld   a, [de]	
	ldi  [hl], a
	inc  de
	dec  c			; bytes left in the row
	jr   nz, .nextX ; If there are still tiles to copy in the row, loop
	;--
	; Move the tilemap pointer to the first tile of the next row
	push de
	ld   d, $00	
	ld   e, $20-BUCKET_WIDTH ; TilesInRow - BlockWidth
	add  hl, de
	pop  de
	;--
	dec  b
	jr   nz, .nextY
BonusGame_NoFrame:
	ret
	
BG_CoinBonus_BucketPull: INCBIN "data/bg/coinbonus/bucket_pull.bin"
BG_CoinBonus_Bucket: INCBIN "data/bg/coinbonus/bucket.bin"
; =============== CoinBonus_SetRoundNum ===============
; Updates the round number in the coins bonus game.
; This is also a tilemap replacement (of a 3x1 tilemap area)
CoinBonus_SetRoundNum:
	; If there's no change request, return
	ld   a, [wCoinBonusRoundBGChg]
	cp   a, $00
	ret  z
	; What round number we need to set?
	ld   a, [wCoinBonusRound]
	cp   a, $01
	jr   z, .round2
	cp   a, $02
	jr   z, .round3
	; [TCRF] We never get here.
	;        But this avoids drawing invalid round numbers.
	ret
.round2:
	ld   de, BG_CoinBonus_Round2	; DE = Tilemap to copy
	jr   .copyBG
.round3:
	ld   de, BG_CoinBonus_Round3	; DE = Tilemap to copy
	
	; Copy the tilemap area
.copyBG:
	ld   hl, vBGCoinBonusRoundNum ; HL = Position of the 1ST/2ND/3RD text in the tilemap
	ld   a, $0F
	ld   b, $03			; Copy 3 tiles
.loop:
	ld   a, [de]		; Copy loop
	ldi  [hl], a
	inc  de
	dec  b
	jr   nz, .loop
	ret
	
BG_CoinBonus_Round2: INCBIN "data/bg/coinbonus/round2.bin"
BG_CoinBonus_Round3: INCBIN "data/bg/coinbonus/round3.bin"
GFX_BonusGame_BullHat: INCBIN "data/gfx/hats/bull_bonusgame.bin"
GFX_BonusGame_JetHat: INCBIN "data/gfx/hats/jet_bonusgame.bin"
GFX_BonusGame_DragonHat: INCBIN "data/gfx/hats/dragon_bonusgame.bin"

; =============== HeartBonus_Do ===============
; See also: CoinBonus_Do
HeartBonus_Do:
	ld   a, $A0						; Static_WriteOBJLst uses another variable for this purpose
	ld   [sWorkOAMPos], a
	call .main
	jp   HeartBonus_WriteOBJ		
.main:
	; Do the mode switch
	ld   a, [wHeartBonusMode]
	rst  $28
	dw HeartBonus_Init
	dw HeartBonus_SelectDifficulty
	dw HeartBonus_InitGame
	dw HeartBonus_Game
	dw HeartBonus_InitResults
	dw HeartBonus_Results
	dw HeartBonus_Exit
; =============== HeartBonus_Init ===============
; Initializes the bonus game.
HeartBonus_Init:
	call StopLCDOperation
	call ClearBGMapEx
	call ClearWorkOAM
	ld   hl, GFXRLE_HeartBonus
	call DecompressGFXStub
	call LoadGFX_BonusGame_WarioPowerHat
	ld   hl, BGRLE_HeartBonus_Menu
	call DecompressBG_ToBGMap
	call HeartBonus_InitVars
	ld   a, LCDC_PRIORITY|LCDC_OBJENABLE|LCDC_WTILEMAP|LCDC_ENABLE
	ldh  [rLCDC], a
	ld   a, BGM_COINBONUS		; Doubles as BGM for difficulty select here
	ld   [sBGMSet], a
	ld   a, $01
	ld   [wHeartBonusShowCoinCount], a
	ld   [wHeartBonusMode], a
	ret
	
; =============== LoadGFX_BonusGame_WarioPowerHat ===============
; Writes the hat graphics for the current Wario hat to VRAM.
; This copies the set of graphics specific to the bonus games,
; which have different and/or unique graphics (ie: diagonal hat).
;
; The compressed GFX already contain the tiles for the PL_POW_GARLIC hat,
; so we don't need to do anything there. 
LoadGFX_BonusGame_WarioPowerHat:
	; Which hat do we have?
	ld   a, [sPlPower]
	cp   a, PL_POW_BULL
	jr   z, .bullHat
	cp   a, PL_POW_JET
	jr   z, .jetHat
	cp   a, PL_POW_DRAGON
	jr   z, .dragonHat
	ret
	
.bullHat:
	ld   de, GFX_BonusGame_BullHat		; DE = Source GFX	
	jr   .writeVRAM
.jetHat:
	ld   de, GFX_BonusGame_JetHat		; DE = Source GFX	
	jr   .writeVRAM
.dragonHat:
	ld   de, GFX_BonusGame_DragonHat	; DE = Source GFX	
.writeVRAM:
	ld   hl, vGFXBonusGamePlHat			; HL = Destination
	ld   b, $11							; B = Number of tiles to write		
.loop:
	ld   c, TILESIZE					; C = Size of a single tile ($10 bytes)
	;--
.loopTile:
	ld   a, [de]		; Copy over the byte...
	ldi  [hl], a		; ...to VRAM
	inc  de				; Next byte
	dec  c				; Have we finished writing the tile?
	jr   nz, .loopTile	; If not, loop
	;--
	dec  b				; Have we written all tiles?
	jr   nz, .loop		; If not, loop
	ret
	
; =============== HeartBonus_InitVars ===============
HeartBonus_InitVars:
	xor  a
	ld   [wHeartBonusHitCount], a		; We aren't in the result screen yet
	ld   [wHeartBonusRoundNum], a			; Set first round
	ld   [wStaticPlLstId], a				
	ld   [wHeartBonusHudBomb0LstId], a		; Hide all bombs in the hud
	ld   [wHeartBonusHudBomb1LstId], a
	ld   [wHeartBonusHudBomb2LstId], a
	ld   [wHeartBonusHudBomb3LstId], a
	ld   [wHeartBonusHudBomb4LstId], a
	; [POI] Clear these as well just in case, to be sure the VBlank handler won't do Coin-bonus specific things
	ld   [wCoinBonusBucketFrameSet], a
	ld   [wCoinBonusRoundBGChg], a
	ldh  [rSCX], a					; Reset scrolling
	ldh  [rSCY], a
	ld   a, HEARTBONUS_SEL_EASY		; Default to easy difficulty
	ld   [wHeartBonusDifficultySel], a
	ld   a, $01						; Enable tile animations
	ld   [wHeartBonusTileAnim], a
	; Set initial player pos (off-screen left)
	ld   a, $F8						
	ld   [wStaticPlX], a
	ld   a, $66
	ld   [wStaticPlY], a
	ld   a, $1C						; Set OBJ palette
	ldh  [rOBP0], a
	ld   a, $E4						; Set BG+OBJ1 palette
	ldh  [rBGP], a
	ldh  [rOBP1], a
; =============== HeartBonus_InitCommon ===============
; Resets various variables, shared across modes.
HeartBonus_InitCommon:
	xor  a
	ld   [wHeartBonusAct], a
	ld   [wStaticPlAnimTimer], a
	ld   [wHeartBonusEnemyTimer], a
	ld   [wHeartBonusBombThrowPathIndex], a
	ld   [wHeartBonusBombLightTimer], a
	ld   [wHeartBonusTimeDecTimer], a
	ld   [wHeartBonusModeTimer], a
	ld   [wHeartBonusTextLstId], a
	ld   [wHeartBonusBombLightLstId], a
	ld   [wHeartBonusBombLstId], a
	ld   [wHeartBonusEnemyLstId], a
	ld   [wHeartBonusShowCursor], a
	ld   [wHeartBonusShowResultFlash], a
	ld   [wHeartBonusShowPowerSel], a
	ld   [wHeartBonusShowCoinCount], a
	ld   [wHeartBonusShowHudLivesHearts], a
	ld   [wHeartBonusShowTime], a
	ld   [wStaticPlFlags], a
	ld   [wHeartBonusPlMode], a ; HEARTBONUS_PLMODE_MOVE -- moving power bar
	ld   [wHeartBonusCoinDec], a
	ld   [wHeartBonusThrowPower], a
	ld   [wHeartBonusLivesChange], a
	ld   [wHeartBonusHeartsChange], a
	ld   [wHeartBonus_Unused_C0EC], a ; [TCRF] Not used anywhere else
	ret
; =============== HeartBonus_SelectDifficulty ===============
; Player comes in an selects a difficulty.
HeartBonus_SelectDifficulty:
	ld   a, [wHeartBonusAct]
	rst  $28
	dw HeartBonus_Menu_Mode_MoveRight
	dw HeartBonus_Menu_Mode_Select
	dw HeartBonus_Menu_Mode_GiveBombs
	
; =============== HeartBonus_Menu_Mode_MoveRight ===============
; Mode $00: Walking right until reaching the target.
HeartBonus_Menu_Mode_MoveRight:
	ld   a, [wStaticPlX]			; Move right 1px
	inc  a
	ld   [wStaticPlX], a
	cp   a, $42						; Reached the target yet?
	jp   nz, Static_Pl_WalkAnim		; If not, animate the walk
.nextMode:
	xor  a							; Otherwise, init
	ld   [wStaticPlAnimTimer], a
	ld   a, OBJ_HEARTBONUS_WARIO_BACK ; Set read frame
	ld   [wStaticPlLstId], a
	ld   a, $01						
	ld   [wHeartBonusShowCursor], a	; Show selection cursor
	ld   [wHeartBonusAct], a		; Next mode
	ret
	
; =============== HeartBonus_Menu_Mode_Select ===============
; Mode $01: Player selects a difficulty level (or the exit).
HeartBonus_Menu_Mode_Select:
	; Since the player doesn't walk when selecting a difficulty, wStaticPlAnimTimer
	; gets reused as wStaticPlAnimTimer to time the coin decrement / bomb adding
	; after selecting a difficulty.
	;
	ld   a, [wStaticPlAnimTimer]
		
	; Wait $14 frames before giving the player controls.
	; Attempting to select an inaccessible difficulty level resets the
	; timer back to $01, and we want to have "NO ACCESS" sfx to	play
	; without being interrupted by the other SFX that plays when moving the cursor.
	cp   a, $14							; Timer == $14?
	jr   z, .doCtrl						; If so, jump
	; After selecting, wait for the coin count to decrement itself by the
	; amount that was specified.
	; (timer won't be increased by BonusGame_UpdateCoinCount until it's done)
	cp   a, $15							; Timer == $15?
	jp   z, BonusGame_UpdateCoinCount	; If so, jump
	; After our timer was set (to $38, for reasons), we can switch to the next mode
	; where our bombs are set one after the other.
	jr   nc, .nextMode					; Timer > $15? If so, jump
	inc  a								; Timer++
	ld   [wStaticPlAnimTimer], a
	ret
.doCtrl:
	ldh  a, [hJoyNewKeys]
	bit  KEYB_A, a						; Pressing A?
	jr   nz, .selectOpt					; If so, select the option
	bit  KEYB_UP, a						; Pressing UP?
	jr   nz, HeartBonus_MoveCursorUp	; If so, move the cursor up
	bit  KEYB_DOWN, a					; Pressing DOWN?
	jr   nz, HeartBonus_MoveCursorDown	; If so, move the cursor down
	ret
	
.nextMode:
	xor  a								; Reset vars
	ld   [wStaticPlAnimTimer], a
	ld   [wHeartBonusCoinDec], a
	ld   a, HEARTBONUS_RTN_BOMBSET		; Next mode
	ld   [wHeartBonusAct], a
	ret
.selectOpt:
	ld   a, [wHeartBonusDifficultySel]
	cp   a, HEARTBONUS_SEL_EXIT			; Are we over the EXIT option?
	jr   nz, HeartBonus_SelectOption	; If not, jump
	; Otherwise, exit the bonus game as usual
	ld   a, SFX1_04						; Play the exit select SFX as well though
	ld   [sSFX1Set], a
	
; =============== HeartBonus_SwitchToExit ===============
; Switches to the mode where the player exits the bonus game to the left.
HeartBonus_SwitchToExit:
	ld   a, $08						; Fade out BGM
	ld   [sBGMActSet], a
	xor  a							
	ld   [wStaticPlAnimTimer], a	; Clear dirty reused value since we're about to walk
	ld   [wHeartBonusAct], a
	ld   a, HEARTBONUS_MODE_EXIT	; New mode
	ld   [wHeartBonusMode], a
	ret
	
; =============== HeartBonus_MoveCursorUp ===============
HeartBonus_MoveCursorUp:
	ld   a, [wHeartBonusDifficultySel]
	cp   a, HEARTBONUS_SEL_HARD			; Are we on the topmost option?
	ret  z								; If so, return
	dec  a								; Otherwise, move selection up
	ld   [wHeartBonusDifficultySel], a
	jr   HeartBonus_PlayCursorMoveSFX
; =============== HeartBonus_MoveCursorDown ===============
HeartBonus_MoveCursorDown:;R
	ld   a, [wHeartBonusDifficultySel]
	cp   a, HEARTBONUS_SEL_EXIT			; Are we on the lowest option?
	ret  z								; If so, return
	inc  a								; Otherwise, move selection down
	ld   [wHeartBonusDifficultySel], a
; =============== HeartBonus_PlayCursorMoveSFX ===============
HeartBonus_PlayCursorMoveSFX:
	ld   a, SFX1_03
	ld   [sSFX1Set], a
	ret
; =============== HeartBonus_SelectOption ===============
; Selects the difficulty option of the game.
HeartBonus_SelectOption:
	; Which difficulty option is the cursor over?
	ld   a, [wHeartBonusDifficultySel]
	cp   a, HEARTBONUS_SEL_MED			; Medium difficulty?
	jr   z, .medium						; If so, jump
	cp   a, HEARTBONUS_SEL_EASY			; Easy difficulty?
	jr   z, .easy						; If so, jump
										; Otherwise, hard difficulty
										
	;
	; Determine if we have the right amount of coins to select this difficulty.
	;
.hard:
	; Hard: Requires 100 coins.
	ld   a, [sLevelCoins_High]
	cp   a, $00							; sLevelCoins_High == 0?					
	jr   z, .notAllowed					; If so, jump
.hardOk:
	ld   a, $01							; Decrement 100 coins
	ld   [wBonusGameCoinChange_High], a
	jr   .startCoinDec
	
.medium:
	; Medium: Requires 40 coins
	
	; Allow access with >= 40 coins
	ld   a, [sLevelCoins_Low]
	sub  a, $40							; sLevelCoins_Low - 40 > 0?
	daa									
	jr   nc, .mediumOk					; If so, jump
	; Always allow with >= 100 coins
	ld   a, [sLevelCoins_High]
	cp   a, $00							; sLevelCoins_High == 0?
	jr   z, .notAllowed					; If so, jump
.mediumOk:
	ld   a, $40							; Decrement 40 coins
	ld   [wBonusGameCoinChange_Low], a
	jr   .startCoinDec
.easy:
	; Easy: Requires 20 coins
	; [TCRF] It's not even possible to select the bonus game if we don't have at least 20 coins.
	;        Though this would be possible to trigger through the unused mode which jumps directly
	;        to the heart bonus game.
	;        Better being safe than crashing for drawing a broken coin count...
	
	; Allow access with >= 20 coins
	ld   a, [sLevelCoins_Low]
	sub  a, $20					; sLevelCoins_Low - 20 > 0?
	daa
	jr   nc, .easyOk			; If so, jump
	; Always allow with >= 100 coins
	ld   a, [sLevelCoins_High]
	cp   a, $00					; sLevelCoins_High == 0?
	jr   z, .notAllowed			; If so, jump
.easyOk:
	ld   a, $20
	ld   [wBonusGameCoinChange_Low], a
	
.startCoinDec:
	ld   a, SFX1_04				; Play OK selection
	ld   [sSFX1Set], a
	ld   a, $15					; [POI] Quick fix to the timing loop in HeartBonus_Menu_Mode_GiveBombs?
	ld   [wStaticPlAnimTimer], a
	ld   a, $01
	ld   [wHeartBonusCoinDec], a
	ret
.notAllowed:
	ld   a, SFX2_01				; Play NO ACCESS sfx
	ld   [sSFX2Set], a
	ret
	
; =============== HeartBonus_Menu_Mode_GiveBombs ===============
; Mode $02: Five bombs are awarded to the player.
HeartBonus_Menu_Mode_GiveBombs:
	; Give the bombs in order, depending on the timer.
	; Every time we give one bomb, play a SFX as well.
	ld   a, [wStaticPlAnimTimer]	; Timer++	
	inc  a
	ld   [wStaticPlAnimTimer], a
	cp   a, $32						; Timer == $32?
	jr   z, .bomb0					; If so, jump
	cp   a, $46						; ...
	jr   z, .bomb1
	cp   a, $5A
	jr   z, .bomb2
	cp   a, $6E
	jr   z, .bomb3
	cp   a, $82
	jr   z, .bomb4
	; When the timer reaches $96, switch to the next mode
	cp   a, $96
	jr   z, .nextMode
	ret
.bomb0:
	ld   a, $01							; Display 1st bomb
	ld   [wHeartBonusHudBomb0LstId], a
	jr   .playSFX						; Play SFX
.bomb1:
	ld   a, $01
	ld   [wHeartBonusHudBomb1LstId], a
	jr   .playSFX
.bomb2:
	ld   a, $01
	ld   [wHeartBonusHudBomb2LstId], a
	jr   .playSFX
.bomb3:
	ld   a, $01
	ld   [wHeartBonusHudBomb3LstId], a
	jr   .playSFX
.bomb4:
	ld   a, $01
	ld   [wHeartBonusHudBomb4LstId], a
.playSFX:
	ld   a, SFX1_01
	ld   [sSFX1Set], a
	ret
.nextMode:
	xor  a
	ld   [wStaticPlAnimTimer], a
	ld   a, HEARTBONUS_MODE_INITGAME
	ld   [wHeartBonusMode], a
	ret
; =============== HeartBonus_InitGame ===============
; Mode $02: Init the main gameplay
HeartBonus_InitGame:
	call StopLCDOperation
	call ClearWorkOAM
	ld   hl, BGRLE_HeartBonus_Game
	call DecompressBG_ToBGMap
	ld   a, LCDC_PRIORITY|LCDC_OBJENABLE|LCDC_WTILEMAP|LCDC_ENABLE
	ldh  [rLCDC], a
	ld   a, BGM_HEARTBONUS
	ld   [sBGMSet], a
	
	
HEARTBONUS_MINPOWERX EQU $0C ; Min X position of the power bar indicator

; =============== HeartBonus_InitNextRound ===============
; Sets up the next round for the bonus game.
HeartBonus_InitNextRound:

	call HeartBonus_InitCommon
	ld   a, $09							; Give 9 seconds before bomb explodes
	ld   [wHeartBonusTime], a
	ld   a, OBJ_HEARTBONUS_WARIO_BACK
	ld   [wStaticPlLstId], a
	; Set player at the center
	ld   a, $42							
	ld   [wStaticPlX], a
	ld   a, $66
	ld   [wStaticPlY], a
	ld   a, $21							; Set enemy walk pos
	ld   [wHeartBonusEnemyY], a
	ld   a, $57							; Align bomb light to bomb (which is part of the player sprite)
	ld   [wHeartBonusBombLightX], a
	ld   a, $5D
	ld   [wHeartBonusBombLightY], a
	ld   a, HEARTBONUS_MINPOWERX		; Align bar indicator to leftmost position (we aren't showing it yet)
	ld   [wHeartBonusPowerSelX], a
	ld   a, HEARTBONUS_MODE_GAME
	ld   [wHeartBonusMode], a
	ret
; =============== HeartBonus_Game ===============
; Mode $03: Main gameplay mode.
HeartBonus_Game:
	ld   a, [wHeartBonusAct]
	rst  $28
	dw HeartBonus_Game_Mode_ReadyText
	dw HeartBonus_Game_Mode_MoveCtrl
	dw HeartBonus_Game_Mode_Throw
	dw HeartBonus_Game_Mode_BombMove
	dw HeartBonus_Game_Mode_BombExplode
	dw HeartBonus_Game_Mode_Timeout
	dw HeartBonus_Game_Mode_Result
	
; =============== HeartBonus_Game_Mode_ReadyText ===============
; Submode $00: The "READY", "GO" text is displayed.
HeartBonus_Game_Mode_ReadyText:
	;
	; Show text in order before switching to the next mode.
	;
	ld   a, [wHeartBonusModeTimer]	; Timer++
	inc  a
	ld   [wHeartBonusModeTimer], a
	cp   a, $3C						; Timer == $3C?
	jr   z, .txtReady				; If so, show "READY"
	cp   a, $82						; Timer == $82?
	jr   z, .txtGo					; If so, show "GO"
	cp   a, $AA						; Timer == $AA?
	jr   z, .nextMode				; If so, switch to the next mode
	ret  nz							; Otherwise, return
.txtReady:
	ld   a, SFX1_12
	ld   [sSFX1Set], a
	ld   a, HEARTBONUS_TEXT_READY
	ld   [wHeartBonusTextLstId], a
	ret
.txtGo:
	ld   a, SFX1_03
	ld   [sSFX1Set], a
	ld   a, HEARTBONUS_TEXT_GO
	ld   [wHeartBonusTextLstId], a
	ret
.nextMode:
	call HeartBonus_InitEnemyPos
	xor  a
	ld   [wHeartBonusModeTimer], a			
	ld   [wHeartBonusTextLstId], a			; Hide text
	ld   a, OBJ_HEARTBONUS_WARIO_BACKGRABBOMB
	ld   [wStaticPlLstId], a
	ld   a, $01								; Enable all gameplay sprites
	ld   [wHeartBonusBombLightLstId], a
	ld   [wHeartBonusShowPowerSel], a
	ld   [wHeartBonusShowTime], a
	ld   [wHeartBonusAct], a				; Next submode
	ret
	
; =============== HeartBonus_InitEnemyPos ===============
; Decides the actor's initial direction and X position when the round starts.
; Whatever the initial position is, it will be (at least partially) off-screen.
HeartBonus_InitEnemyPos:
	; 50% chance of spawning from either direction
	ldh  a, [rDIV]
	bit  0, a
	jr   nz, .moveRight
.moveLeft:
	ld   a, STATIC_OBJLST_XFLIP			; Face left
	ld   [wHeartBonusEnemyFlags], a
	
	; 50% chance of spawning 8px to the left than the usual position.
	ldh  a, [rDIV]
	bit  1, a
	jr   nz, .closeL
.farL:
	ld   a, SCREEN_H+$08
	ld   [wHeartBonusEnemyX], a
	ret
.closeL:
	ld   a, SCREEN_H
	ld   [wHeartBonusEnemyX], a
	ret
	
.moveRight:
	xor  a								; Face right
	ld   [wHeartBonusEnemyFlags], a
	
	; 50% chance of spawning 8px to the right than the usual position.
	ldh  a, [rDIV]
	bit  1, a
	jr   nz, .closeR
.farR:
	ld   a, -$10						; Off-screen, left
	ld   [wHeartBonusEnemyX], a
	ret
.closeR:
	ld   a, -$10+$08
	ld   [wHeartBonusEnemyX], a
	ret
	
; =============== HeartBonus_Game_Mode_MoveCtrl ===============
; Submode $01: Allows player movement.
HeartBonus_Game_Mode_MoveCtrl:
	call HeartBonus_IncPowerBar
	call HeartBonus_DoTimer
	call HeartBonus_DoEnemy
	call HeartBonus_ChkHoldThrow
	call HeartBonus_DoThrownBombLight
	
.doDirCtrl:
	; Handle left/right directional controls
	ldh  a, [hJoyKeys]
	bit  KEYB_RIGHT, a		
	jp   nz, .moveR
	bit  KEYB_LEFT, a
	jp   nz, .moveL
	ret
.moveR:
	; Move right until reaching the rightmost position
	ld   a, [wStaticPlX]
	cp   a, $52						; Player X == $52?
	ret  z							; If so, don't move any further
	inc  a							; X++
	ld   [wStaticPlX], a
	ld   a, [wHeartBonusBombLightX]	; Keep light in sync
	inc  a
	ld   [wHeartBonusBombLightX], a
	ret
.moveL:
	; Move left until reaching the rightmost position
	ld   a, [wStaticPlX]
	cp   a, $32						; Player X == $32?
	ret  z							; If so, don't move any further
	dec  a							; X--
	ld   [wStaticPlX], a
	ld   a, [wHeartBonusBombLightX]	; Keep light in sync
	dec  a
	ld   [wHeartBonusBombLightX], a
	ret
	
; =============== HeartBonus_IncPowerBar ===============
; Increases the power bar by 2px. When reaching the end, it loops.
HeartBonus_IncPowerBar:
	; Lock the power bar once we've pressed/held A
	ld   a, [wHeartBonusPlMode]
	cp   a, HEARTBONUS_PLMODE_MOVE		; Is the power bar moving?
	ret  nz								; If not, return
	
	;
	; Every time the powerbar timer increases, move the arrow sprite 2px to the right.
	; The bar is $40px long, so when the timer reaches $20, reset its X position.
	;
	ld   a, [wHeartBonusThrowPower]
	cp   a, $20							; Are we in the last position? (position id == $20)
	jr   z, .resetBar						; If so, loop to the lowest power
	inc  a								; PositionId++
	ld   [wHeartBonusThrowPower], a
	ld   a, [wHeartBonusPowerSelX]		; Move bar indicator right by 2px
	inc  a
	inc  a
	ld   [wHeartBonusPowerSelX], a
	ret
.resetBar:
	ld   a, SFX1_29
	ld   [sSFX1Set], a
	xor  a
	ld   [wHeartBonusThrowPower], a
	ld   a, HEARTBONUS_MINPOWERX
	ld   [wHeartBonusPowerSelX], a
	ret
	
; =============== HeartBonus_DoTimer ===============
; Handles the time limit in the bonus game.
; Every time a second ticks down, the bomb light also moves down (closer to the bomb) by 1px.
HeartBonus_DoTimer:
	; Wait for the tickdown timer to reach $46
	ld   a, [wHeartBonusTimeDecTimer]	; Timer++
	inc  a
	ld   [wHeartBonusTimeDecTimer], a
	cp   a, $46							; Timer != $46?
	ret  nz								; If so, return
	; Otherwise, decrease the time limit
	xor  a								; Reset tickdown timer
	ld   [wHeartBonusTimeDecTimer], a
	ld   a, [wHeartBonusBombLightY]		; Move light down by 1px
	inc  a
	ld   [wHeartBonusBombLightY], a
	ld   a, [wHeartBonusTime]			; TimeLeft--
	dec  a
	ld   [wHeartBonusTime], a
	cp   a, $00							; Is there any time left?
	ret  nz								; If so, return
	; Otherwise, make the bomb explode. This counts as a missed shot.
	xor  a
	ld   [wStaticPlAnimTimer], a
	ld   a, HEARTBONUS_RTN_TIMEOUT
	ld   [wHeartBonusAct], a
	ret
	
; =============== HeartBonus_MoveEnemyUp ===============
; When moving the enemy after hitting it with a bomb.
HeartBonus_MoveEnemyUp:
	ld   a, [wHeartBonusEnemyY]	; Y--
	dec  a
	ld   [wHeartBonusEnemyY], a
	ret
	
; =============== HeartBonus_DoEnemy ===============
; Handles the enemy the enemy target in the bonus game.
HeartBonus_DoEnemy:
	; If we hit the enemy, only move it vertically up
	ld   a, [wHeartBonusEnemyHit]
	cp   a, $01						; HitStatus == 1?
	jr   z, HeartBonus_MoveEnemyUp	; If so, jump
	
	
	;
	; Determine the animation frame of the walk cycle to use, based off the anim timer.
	; Since this is used for *all* enemy types, it means they must have the
	; same number of frames.
	;
	
	; The timer should be in range $00-$28. Once it reaches $28, reset back to $00.
	ld   a, [wHeartBonusEnemyTimer]	; AnimTimer++
	inc  a
	ld   [wHeartBonusEnemyTimer], a
	cp   a, $0A						; AnimTimer == $0A?
	jr   z, .useFrame2				; If so, jump
	cp   a, $14						; ...
	jr   z, .useFrame1
	cp   a, $1E
	jr   z, .useFrame3
	cp   a, $28						
	jr   z, .useFrame1_resetTimer	
	jr   .moveH
.useFrame2:
	ld   a, HEARTBONUS_OBJ_ENEMYWALK1
	jr   .setFrame
.useFrame1:
	ld   a, HEARTBONUS_OBJ_ENEMYWALK0
	jr   .setFrame
.useFrame3:
	ld   a, HEARTBONUS_OBJ_ENEMYWALK2
	jr   .setFrame
.useFrame1_resetTimer:
	xor  a
	ld   [wHeartBonusEnemyTimer], a
	ld   a, HEARTBONUS_OBJ_ENEMYWALK0
.setFrame:
	ld   [wHeartBonusEnemyLstId], a
	
.moveH:
	;
	; Move the enemy horizontally.
	; To account for the different enemy speed, depending on difficulty
	; we may call the movement subroutine multiple times.
	;
	
	; Check which difficulty we're on
	ld   a, [wHeartBonusDifficultySel]
	cp   a, HEARTBONUS_SEL_HARD			; Hard difficulty?
	jr   z, .hard						; If so, jump (1.5px/frame)
	cp   a, HEARTBONUS_SEL_EASY			; Easy difficulty?
	jr   z, .easy						; If so, jump (0.5px/frame)
.med:
	jr   HeartBonus_MoveEnemyH			; Medium difficulty, 1px/frame
.hard:
	; Always call the movement subroutine once.
	; Every other frame, also call it a second time.
	ld   a, [wHeartBonusModeTimer]		; Timer++
	inc  a
	ld   [wHeartBonusModeTimer], a
	bit  0, a							; Timer % 2 == 0?	
	call z, HeartBonus_MoveEnemyH		; If so, call
	jr   HeartBonus_MoveEnemyH			
.easy:
	; Every other frame, we return immediately.
	; Code falls down to the movement subroutine.
	ld   a, [wHeartBonusModeTimer]		; Timer++
	inc  a
	ld   [wHeartBonusModeTimer], a
	bit  0, a							; Timer % 2 == 0?	
	ret  z								; If so, return
	
; =============== HeartBonus_MoveEnemyH ===============
; Moves the enemy horizontally by 1px.
HeartBonus_MoveEnemyH:
	ld   a, [wHeartBonusEnemyFlags]
	bit  STATIC_OBJLSTB_XFLIP, a		; Facing left?
	jr   z, .moveR						; If not, move right
.moveL:
	; Move the enemy left until it's off-screen
	ld   a, [wHeartBonusEnemyX]
	cp   a, -$10					; X == -$10?
	jr   z, .newInitPos				; If so, jump
	dec  a							; Otherwise, X--
	ld   [wHeartBonusEnemyX], a
	ret
.moveR:
	; Move the enemy right until it's off-screen
	ld   a, [wHeartBonusEnemyX]
	cp   a, SCREEN_H+$10			; X == $B0?
	jr   z, .newInitPos				; If so, jump
	inc  a
	ld   [wHeartBonusEnemyX], a
	ret
.newInitPos:
	; Randomize the new direction/spawn position instead of just turning
	; as it would be customary, to make it less predictable.
	call HeartBonus_InitEnemyPos		; Set new pos
	xor  a								; Reset walk anin
	ld   [wHeartBonusEnemyTimer], a
	ret
	
; =============== HeartBonus_ChkHoldThrow ===============
; Handles the throw controls for the player.
HeartBonus_ChkHoldThrow:
	; If we have no seconds left, don't allow throwing the bomb
	ld   a, [wHeartBonusTime]
	cp   a, $00						
	ret  z
	
	;
	; We can be in two possible movement modes here:
	; - HEARTBONUS_PLMODE_MOVE, where the power bar is moving.
	;   When pressing A, we "lock on" and stop movement (switch to HEARTBONUS_PLMODE_LOCK).
	; - HEARTBONUS_PLMODE_LOCK, where releasing A throws the bomb.
	;
	
	ld   a, [wHeartBonusPlMode]
	cp   a, HEARTBONUS_PLMODE_MOVE	; Is the power bar moving?
	jr   nz, .chkThrow				; If not, jump
.chkLock:
	ldh  a, [hJoyNewKeys]
	bit  KEYB_A, a					; Did we press A?
	jr   nz, .lockOn				; If so, lock on
	ret
.chkThrow:
	ldh  a, [hJoyKeys]
	bit  KEYB_A, a					; Are we holding A?
	jr   nz, .lockOn				; If so, keep locking on
.nextSubmode:
	; Otherwise, we're throwing the bomb.
	xor  a							; Reset anim timer
	ld   [wStaticPlAnimTimer], a
	ld   a, HEARTBONUS_OBJ_BOMBLIGHT0
	ld   [wHeartBonusBombLightLstId], a
	ld   a, OBJ_HEARTBONUS_WARIO_BACKHOLDBOMB0
	ld   [wStaticPlLstId], a
	ld   a, HEARTBONUS_PLMODE_THROW	; Set throw mode
	ld   [wHeartBonusPlMode], a
	ld   [wHeartBonusAct], a		; And next submode HEARTBONUS_RTN_THROW
	ret
	
.lockOn:
	ld   a, [wHeartBonusPlMode]
	cp   a, HEARTBONUS_PLMODE_LOCK	; Are we already locked?					
	jr   z, .doPlLockAnim			; If so, don't reinit again
	
	; Otherwise, we currently have HEARTBONUS_PLMODE_MOVE.
	; Prepare the switch to the locked PlMode.
	ld   a, SFX1_2F					; Play lock SFX
	ld   [sSFX1Set], a
	ld   a, HEARTBONUS_PLMODE_LOCK	; New PlMode
	ld   [wHeartBonusPlMode], a
	
	; Align the bomb light to the new anim. frame we're setting
	ld   a, [wStaticPlX]			
	add  $13						; wHeartBonusBombLightX = wStaticPlX+13
	ld   [wHeartBonusBombLightX], a
	ld   a, [wHeartBonusBombLightY]	; Move light down by 4px
	add  $04
	ld   [wHeartBonusBombLightY], a
	
	jr   .useFrame0_resetTimer		; Set new anim. frame
	
.doPlLockAnim:
	; When we're already in power locked mode, play the hold animation.
	; Switch frames every $0F frames.
	ld   a, [wStaticPlAnimTimer]
	inc  a
	ld   [wStaticPlAnimTimer], a
	cp   a, $0F*$01
	jr   z, .useFrame1
	cp   a, $0F*$02
	jr   z, .useFrame0_resetTimer
	ret
.useFrame1:
	ld   a, OBJ_HEARTBONUS_WARIO_BACKHOLDBOMB1
	ld   [wStaticPlLstId], a
	ret
.useFrame0_resetTimer:
	xor  a
	ld   [wStaticPlAnimTimer], a
	ld   a, OBJ_HEARTBONUS_WARIO_BACKHOLDBOMB0
	ld   [wStaticPlLstId], a
	ret
	
; =============== HeartBonus_DoThrownBombLight ===============
; Animates the bomb's light.
HeartBonus_DoThrownBombLight:
	; Animate every $0F frames
	ld   a, [wHeartBonusBombLightTimer]
	inc  a
	ld   [wHeartBonusBombLightTimer], a
	cp   a, $0F*$01
	jr   z, .useFrame2
	cp   a, $0F*$02
	jr   z, .useFrame1
	ret
.useFrame2:
	ld   a, HEARTBONUS_OBJ_BOMBLIGHT1
	ld   [wHeartBonusBombLightLstId], a
	ret
.useFrame1:
	ld   a, SFX4_14						; Play tick sfx
	ld   [sSFX4Set], a
	xor  a
	ld   [wHeartBonusBombLightTimer], a
	ld   a, HEARTBONUS_OBJ_BOMBLIGHT0
	ld   [wHeartBonusBombLightLstId], a
	ret
	
; =============== HeartBonus_Game_Mode_Throw ===============
; Submode $02: Handles the initial part of the throw animation.
HeartBonus_Game_Mode_Throw:
	call HeartBonus_DoEnemy			; Continue moving the enemy
	
	; Do the timing sequence for the player throw anim
	ld   a, [wStaticPlAnimTimer]	; Timer++
	inc  a
	ld   [wStaticPlAnimTimer], a
	cp   a, $03
	jr   z, .setFrame
	cp   a, $08
	jr   z, .nextSubmode
	ret
.setFrame:
	ld   a, OBJ_HEARTBONUS_WARIO_BACKGRABBOMB
	ld   [wStaticPlLstId], a
	ret
.nextSubmode:
	call HeartBonus_SetBombThrowPath
	ld   a, SFX1_0C					; Play throw SFX
	ld   [sSFX1Set], a
	xor  a							; Reset anim timer
	ld   [wStaticPlAnimTimer], a
	ld   a, HEARTBONUS_OBJ_BOMB0	; Set bomb frame
	ld   [wHeartBonusBombLstId], a
	ld   a, [wStaticPlX]			; BombX = PlX + $18 (aligned close to player's right)
	add  $18
	ld   [wHeartBonusBombX], a
	ld   a, $68						; BombY = $68
	ld   [wHeartBonusBombY], a
	ld   a, OBJ_HEARTBONUS_WARIO_BACKTHROWBOMB
	ld   [wStaticPlLstId], a
	ld   a, HEARTBONUS_RTN_BOMBMOVE	; Next submode
	ld   [wHeartBonusAct], a
	ret
	
; =============== HeartBonus_SetBombThrowPath ===============
; Sets the ID of the bomb's throw path and its initial index.
HeartBonus_SetBombThrowPath:

	; There are $20 different positions in the power bar, which map to $08 unique paths
	; the bomb can take.
	; Indexing the table with the throw power gets us the respective path ID.
	ld   hl, HeartBonus_PowerAssocTbl	; HL = Table of speed assoc
	ld   b, $00							; BC = Throw power value
	ld   a, [wHeartBonusThrowPower]
	ld   c, a
	add  hl, bc							; Index the table
	ld   a, [hl]						; Set the path id
	ld   [wHeartBonusThrowPathId], a
	
	; 
	; Because the ThrowPaths are read backwards, we also need the initial index
	; for each of the path tables.
	; This should point to the last entry of the tables.
	;
	ld   hl, HeartBonus_PowerInitTbl	; HL = Table
	ld   c, a							; BC = PathID
	add  hl, bc							; Index the table
	ld   a, [hl]						; Set the value
	ld   [wHeartBonusBombThrowPathIndex], a
	ret
	
; =============== HeartBonus_PowerAssocTbl ===============
; This table maps possible values of wHeartBonusThrowPower to wHeartBonusThrowPathId.
HeartBonus_PowerAssocTbl: 
	db $00,$01,$01,$01,$01,$02,$02,$02,$02,$02,$02,$03,$03,$03,$03,$03	; $00
	db $03,$04,$04,$04,$04,$04,$04,$05,$05,$05,$05,$06,$06,$06,$06,$06	; $10
	db $07																; $20
; =============== HeartBonus_PowerAssocTbl ===============
HeartBonus_PowerInitTbl: 
	db $1F ; Size of HeartBonus_ThrowPath0 - 1
	db $2F ; Size of HeartBonus_ThrowPath1 - 1
	db $47 ; Size of HeartBonus_ThrowPath2 - 1
	db $35 ; Size of HeartBonus_ThrowPath3 - 1
	db $5F ; Size of HeartBonus_ThrowPath4 - 1
	db $47 ; Size of HeartBonus_ThrowPath5 - 1
	db $33 ; Size of HeartBonus_ThrowPath6 - 1
	db $10 ; Size of HeartBonus_ThrowPath7 - 1
	
; =============== HeartBonus_Game_Mode_BombMove ===============
; Submode $03: Makes the bomb move in the previously set path.
HeartBonus_Game_Mode_BombMove:
	call HeartBonus_DoEnemy					; Continue moving enemy
	call HeartBonus_DoThrownBomb			; Move bomb
	
	;
	; Check if the bomb is still moving in the path.
	;
	; [POI] It could have been cp a, $FF to make use of the last frame.
	ld   a, [wHeartBonusBombThrowPathIndex]
	cp   a, $00								; Index != 0?
	ret  nz									; If so, the bomb is still moving

.nextSubmode:
	;
	; Otherwise, make the bomb explode.
	;

	xor  a									; Clear all
	ld   [wHeartBonusExplTimer], a
	ld   [wHeartBonusBombLstId], a
	ld   [wHeartBonusBombLightLstId], a
	ld   a, OBJ_HEARTBONUS_WARIO_BACK		; Set player frame
	ld   [wStaticPlLstId], a
	ld   a, HEARTBONUS_RTN_BOMBEXPLODE		; Next submode
	ld   [wHeartBonusAct], a
	
	;
	; And check if we managed to hit the enemy.
	;
	
	; The first four paths don't make the bomb go far enough.
	; (no need to check the Y position directly, though that would be more flexible)
	ld   a, [wHeartBonusThrowPathId]
	cp   a, HEARTBONUS_BOMBPATH_GOOD0		; PathId < 4?
	jr   c, .noHit							; If so, jump
	
	; If we're outside the horizontal range (distance >= $0Apx), we didn't hit the actor
	ld   a, [wHeartBonusBombX]				; B = BombX
	ld   b, a
	ld   a, [wHeartBonusEnemyX]				; A = EnemyX
	sub  a, b								; Diff = EnemyX - BombX
	; This may be either negative or positive...
	jr   c, .chkNegDiff						; Diff < 0? If so, jump
.chkPosDiff:
	cp   a, +$0A							; Distance >= $0A?
	jr   nc, .noHit							; If so, we didn't hit
	jr   .hit
.chkNegDiff:
	; [POI] By mistake it's larger here (and "jr c" contributes too)
	cp   a, -$0B							; Distance > $0B?
	jr   c, .noHit							; If so, we didn't hit
.hit:
	ld   a, SFX1_2B							; Play both success SFX
	ld   [sSFX1Set], a
	ld   a, SFX4_02							; And bomb explosion SFX
	ld   [sSFX4Set], a
	ld   a, HEARTBONUS_OBJ_ENEMYSTUN		; Set stun frame (again, common id across 3 enemies)
	ld   [wHeartBonusEnemyLstId], a
	ld   a, [wHeartBonusEnemyY]				; EnemyY += $03 to slightly increase the upwards movement time
	add  $03
	ld   [wHeartBonusEnemyY], a
	ld   a, $01								; Mark as hit so it will move up
	ld   [wHeartBonusEnemyHit], a
	ret
.noHit:
	ld   a, SFX4_02							; Play bomb explosion SFX
	ld   [sSFX4Set], a
	ret
	
; =============== HeartBonus_DoThrownBomb ===============
; Animates and moves the thrown bomb.
HeartBonus_DoThrownBomb:
	; Avoid animating the bomb at the lowest throw speed
	ld   a, [wHeartBonusThrowPathId]
	cp   a, $00
	jr   z, .chkPath
	
	; Animate the bomb every 4 frames (of movement).
	; This makes it look like the shiny part changes positions.
	ld   a, [wHeartBonusBombThrowPathIndex]
	bit  2, a								; (Timer & $04) != 0?
	jr   nz, .useFrame2						; If so, use frame 2
.useFrame1:
	ld   a, HEARTBONUS_OBJ_BOMB0
	ld   [wHeartBonusBombLstId], a
	ld   [wHeartBonusBombLightLstId], a
	jr   .chkPath
.useFrame2:
	xor  a
	ld   [wHeartBonusBombLightLstId], a
	ld   a, HEARTBONUS_OBJ_BOMB1
	ld   [wHeartBonusBombLstId], a
.chkPath:

	; Determine the throw path.
	; 
	; The only thing each HeartBonus_SetThrowPath* does is preparing a call to HeartBonus_SetThrowPath.
	; Using rst $28 wasn't really necessary for this.
	
	ld   a, [wHeartBonusThrowPathId]
	rst  $28
	dw HeartBonus_SetThrowPath0
	dw HeartBonus_SetThrowPath1
	dw HeartBonus_SetThrowPath2
	dw HeartBonus_SetThrowPath3
	dw HeartBonus_SetThrowPath4
	dw HeartBonus_SetThrowPath5
	dw HeartBonus_SetThrowPath6
	dw HeartBonus_SetThrowPath7
	
; =============== PATH DEFINITIONS AND WRAPPERS ===============

; Path 0: Going nowhere
HeartBonus_SetThrowPath0:
	ld   hl, HeartBonus_ThrowPath0
	jp   HeartBonus_SetThrowPath
HeartBonus_ThrowPath0: 
	db $6D,$6C,$6C,$6E,$6E,$6F,$6F,$70,$70,$71,$71,$72,$72,$73,$73,$73
	db $72,$72,$72,$71,$71,$70,$70,$6F,$6F,$6E,$6E,$6D,$6C,$6B,$6A,$69
HeartBonus_SetThrowPath1:
	ld   hl, HeartBonus_ThrowPath1
	jp   HeartBonus_SetThrowPath
HeartBonus_ThrowPath1:
	db $5F,$5E,$5D,$5C,$5B,$5A,$59,$58,$57,$56,$55,$54,$53,$53,$52,$52
	db $52,$51,$51,$50,$50,$4F,$4F,$4F,$50,$50,$51,$51,$52,$52,$53,$53
	db $54,$54,$55,$55,$56,$57,$58,$59,$5A,$5B,$5C,$5E,$60,$62,$64,$66
HeartBonus_SetThrowPath2:
	ld   hl, HeartBonus_ThrowPath2
	jp   HeartBonus_SetThrowPath
HeartBonus_ThrowPath2:
	db $50,$4E,$4C,$4A,$48,$47,$46,$45,$44,$43,$42,$41,$40,$3F,$3E,$3D
	db $3C,$3B,$3A,$39,$38,$37,$36,$35,$34,$33,$32,$31,$30,$2F,$2F,$2E
	db $2E,$2D,$2D,$2C,$2C,$2C,$2D,$2D,$2E,$2F,$30,$31,$32,$33,$34,$35
	db $36,$37,$38,$39,$3A,$3B,$3C,$3E,$40,$42,$44,$46,$48,$4A,$4C,$4E
	db $50,$52,$54,$56,$58,$5C,$60,$64
HeartBonus_SetThrowPath3:;I
	ld   hl, HeartBonus_ThrowPath3
	jp   HeartBonus_SetThrowPath
HeartBonus_ThrowPath3:
	db $4A,$48,$46,$44,$42,$40,$3E,$3D,$3C,$3B,$3A,$39,$38,$37,$36,$35
	db $34,$33,$32,$31,$31,$30,$30,$2F,$2F,$2F,$30,$30,$31,$31,$32,$32
	db $33,$33,$34,$35,$36,$37,$38,$39,$3A,$3C,$3E,$40,$43,$45,$48,$4C
	db $50,$54,$58,$5C,$60,$64
HeartBonus_SetThrowPath4:;I
	ld   hl, HeartBonus_ThrowPath4
	jp   HeartBonus_SetThrowPath
HeartBonus_ThrowPath4:
	db $23,$22,$22,$22,$21,$21,$21,$20,$20,$20,$21,$21,$22,$22,$23,$23
	db $24,$24,$25,$25,$26,$26,$27,$27,$28,$29,$2A,$2B,$2C,$2D,$2E,$2F
	db $30,$2E,$2C,$2A,$29,$28,$27,$26,$25,$24,$23,$22,$21,$20,$20,$1F
	db $1F,$1E,$1E,$1D,$1D,$1D,$1E,$1E,$1F,$1F,$20,$20,$21,$21,$22,$23
	db $24,$25,$26,$27,$28,$29,$2A,$2B,$2C,$2D,$2E,$30,$32,$34,$36,$38
	db $3A,$3C,$3E,$40,$42,$44,$46,$49,$4C,$4F,$52,$55,$58,$5C,$60,$64
HeartBonus_SetThrowPath5:
	ld   hl, HeartBonus_ThrowPath5
	jp   HeartBonus_SetThrowPath
HeartBonus_ThrowPath5:
	db $22,$21,$20,$1F,$1E,$1D,$1C,$1B,$1A,$1A,$19,$19,$18,$18,$17,$17
	db $16,$16,$15,$15,$15,$14,$14,$14,$13,$13,$13,$12,$12,$12,$13,$13
	db $14,$14,$15,$15,$16,$16,$17,$18,$19,$1A,$1B,$1C,$1D,$1E,$1F,$20
	db $22,$24,$26,$28,$2A,$2C,$2E,$30,$33,$36,$39,$3C,$3F,$42,$45,$48
	db $4B,$4E,$51,$54,$58,$5C,$60,$64
HeartBonus_SetThrowPath6:
	ld   hl, HeartBonus_ThrowPath6
	jp   HeartBonus_SetThrowPath
HeartBonus_ThrowPath6:
	db $20,$1F,$1F,$1E,$1E,$1D,$1D,$1C,$1C,$1C,$1B,$1B,$1B,$1A,$1A,$1A
	db $19,$19,$19,$18,$18,$18,$18,$19,$19,$1A,$1A,$1B,$1B,$1C,$1D,$1E
	db $1F,$20,$22,$24,$26,$28,$2A,$2D,$33,$36,$3A,$3E,$42,$46,$4A,$4E
	db $52,$56,$5C,$62
HeartBonus_SetThrowPath7:
	ld   hl, HeartBonus_ThrowPath7
	jp   HeartBonus_SetThrowPath
; Path 7: Near instant hit
HeartBonus_ThrowPath7:
	db $1E,$1F,$20,$22,$24,$28,$2C,$30,$34,$38,$3C,$40,$46,$4C,$52,$58
	db $60

; =============== HeartBonus_SetThrowPath ===============
; Updates the bomb's Y position to follow the specified path.
;
; These paths, unlike most other paths in the game, are read backwards.
; The index starts at the last entry and is decreased every time a new Y pos is indexed.
; This appears to have been done for ease in checking when the path's over -- as
; all it's needed to do is checking if the index is 0.
; [TCRF] And because of this, none of the bomb paths make use of the first byte, for whatever it's worth.
;--
; The Y positions themselves aren't offset to the current position -- they
; simply replace the current bomb's position.
;
; IN
; - HL: Ptr to ThrowPath
HeartBonus_SetThrowPath:
	ld   b, $00								; BC = Index
	ld   a, [wHeartBonusBombThrowPathIndex]
	ld   c, a
	add  hl, bc								; Index the path
	ld   a, [hl]							; A = New Y position
	ld   [wHeartBonusBombY], a				; Set it directly as the bomb's position
	
	; Sync the bomb's light fuse
	
	; [POI] It's unnecessary to update the X coord.
	ld   a, [wHeartBonusBombX]				; BombLightX = BombX - $03
	sub  a, $03
	ld   [wHeartBonusBombLightX], a
	
	ld   a, [wHeartBonusBombY]				; BombLightY = BombY - $06
	sub  a, $06
	ld   [wHeartBonusBombLightY], a
	ld   a, [wHeartBonusBombThrowPathIndex]	; Index--
	dec  a
	ld   [wHeartBonusBombThrowPathIndex], a
	ret
	
; =============== HeartBonus_Game_Mode_BombExplode ===============
; Submode $04: The bomb explode.
HeartBonus_Game_Mode_BombExplode:
	; Continue moving the enemy (either horizontally if not hit, or vertically if so)
	call HeartBonus_DoEnemy						
	
	; Do the timing sequence for the explosion animation (under the bomb OBJLst)
	ld   a, [wHeartBonusExplTimer]
	inc  a
	ld   [wHeartBonusExplTimer], a
	cp   a, $05
	jr   z, .setFrame4
	cp   a, $11
	jr   z, .setFrame5
	cp   a, $2D
	jr   z, .hide
	cp   a, $37
	jr   z, HeartBonus_DoPostHitMiss
	ret
.setFrame4:
	ld   a, HEARTBONUS_OBJ_BOMBEXPL1
	ld   [wHeartBonusBombLstId], a
	ret
.setFrame5:
	ld   a, HEARTBONUS_OBJ_BOMBEXPL2
	ld   [wHeartBonusBombLstId], a
	ret
.hide:
	xor  a
	ld   [wHeartBonusBombLstId], a
	ret
	
; =============== HeartBonus_DoPostHitMiss ===============
; Does the last actions before the round ends (shared across modes).
HeartBonus_DoPostHitMiss:
	;
	; Updates the current bomb icon in the HUD to mark if there was a hit or miss.
	;
	ld   a, [wHeartBonusEnemyHit]
	cp   a, $00								; Did we hit the enemy?
	jr   z, .setMissIcon					; If not, jump
	
.chkAllClear:
	;--
	; If we hit all 5 enemies successfully, play an extra SFX
	ld   a, [wHeartBonusHitCount]			; HitCount++
	inc  a
	ld   [wHeartBonusHitCount], a
	cp   a, $05								; HitCount == 5?
	jr   nz, .setHitIcon					; If not, skip
	ld   a, SFX1_08							; Well done!
	ld   [sSFX1Set], a
	;--
.setHitIcon:
	ld   b, HEARTBONUS_OBJ_BOMBICON_HIT		; B = New OBJLstId for bomb icon
	jr   .chkRoundNum
.setMissIcon:
	ld   b, HEARTBONUS_OBJ_BOMBICON_MISS	; B = New OBJLstId for bomb icon
.chkRoundNum:

	; Depending on the current round number, update the correct icon in the HUD
	ld   a, [wHeartBonusRoundNum]
	cp   a, $01
	jr   z, .setRound2Icon
	cp   a, $02
	jr   z, .setRound3Icon
	cp   a, $03
	jr   z, .setRound4Icon
	cp   a, $04
	jr   z, .setRound5Icon
.setRound1Icon:
	ld   a, b							; Set the icon
	ld   [wHeartBonusHudBomb0LstId], a
	jr   .setPlFrame
.setRound2Icon:
	ld   a, b
	ld   [wHeartBonusHudBomb1LstId], a
	jr   .setPlFrame
.setRound3Icon:
	ld   a, b
	ld   [wHeartBonusHudBomb2LstId], a
	jr   .setPlFrame
.setRound4Icon:
	ld   a, b
	ld   [wHeartBonusHudBomb3LstId], a
	jr   .setPlFrame
.setRound5Icon:
	ld   a, b
	ld   [wHeartBonusHudBomb4LstId], a
.setPlFrame:
	; If the bomb exploded on us (we came from the timeout mode),
	; prevent normal player animations from playing by skipping ahead
	; in the timing sequence.
	ld   a, [wHeartBonusAct]
	cp   a, HEARTBONUS_RTN_TIMEOUT	; Mode == $05?
	jp   z, .noResultAnim			; If so, jump
	
	; Otherwise, setup for those animations
	ld   a, OBJ_STATIC_WARIO_FRONT	; Set front facing frame
	ld   [wStaticPlLstId], a
	
	; If we missed the enemy, play an extra SFX
	ld   a, [wHeartBonusEnemyHit]
	cp   a, $01						; Did we hit the enemy?
	jr   z, .nextSubmode			; If so, jump
	ld   a, SFX2_01					; Play "miss" SFX
	ld   [sSFX2Set], a
.nextSubmode:
	ld   a, HEARTBONUS_RTN_RESULT
	ld   [wHeartBonusAct], a
	ret
.noResultAnim:
	; We don't play the "miss" SFX here since we already did this in HeartBonus_Game_Mode_Timeout.onTimer78
	ld   a, $28
	ld   [wStaticPlAnimTimer], a
	jr   .nextSubmode
	
; =============== HeartBonus_Game_Mode_Timeout ===============
; Submode $05: Bomb explodes on us.
HeartBonus_Game_Mode_Timeout:
	call HeartBonus_DoEnemy				; Continue moving enemy
	xor  a								; Remove bomb
	ld   [wHeartBonusBombLightLstId], a
	
	; Time the player anim sequence
	ld   a, [wStaticPlAnimTimer]		; AnimTimer++	
	inc  a
	ld   [wStaticPlAnimTimer], a
	cp   a, $0A
	jr   z, .onTimer0A
	cp   a, $19
	jr   z, .onTimer19
	cp   a, $28
	jr   z, .onTimer28
	cp   a, $50
	jr   z, .onTimer50
	cp   a, $78
	jp   z, .onTimer78
	cp   a, $C8
	jp   z, HeartBonus_DoPostHitMiss
	ret
.onTimer0A:;R
	ld   a, SFX4_0B					; Play SFX
	ld   [sSFX4Set], a
	ld   a, HEARTBONUS_OBJ_BOMBEXPL1					
	ld   [wHeartBonusBombLstId], a
	
	;
	; Determine which animation frame to use depending on player mode.
	; We have to do this since the player uses a different animation frame
	; when the power bar is locked (holding A), with the bomb being placed elsewhere.
	;
	; We've also got to align the separate bomb sprite (for the explosion)
	; over the bomb's location that appears in the OBJ_HEARTBONUS_WARIO_BACK*BOMBEXPL0 frames.
	;
	; We only need to do this here, then we can simply increase the bomb and player frame ID.
	;
	ld   a, [wHeartBonusPlMode]
	cp   a, HEARTBONUS_PLMODE_MOVE	; Power bar moving?
	jr   nz, .onTimer0A_lock		; If not, jump
.onTimer0A_main:
	ld   a, OBJ_HEARTBONUS_WARIO_BACKGRABBOMBEXPL0
	ld   [wStaticPlLstId], a
	ld   a, [wStaticPlX]			; ExplosionX = PlX + $11
	add  $11
	ld   [wHeartBonusBombX], a
	ld   a, [wStaticPlY]			; ExplosionY = PlY + $11
	sub  a, $02
	ld   [wHeartBonusBombY], a
	ret
.onTimer0A_lock:
	ld   a, OBJ_HEARTBONUS_WARIO_BACKHOLDBOMBEXPL0
	ld   [wStaticPlLstId], a
	ld   a, [wStaticPlX]			; ExplosionX = PlX + $10
	add  $10
	ld   [wHeartBonusBombX], a		
	ld   a, [wStaticPlY]			; ExplosionY = PlY
	ld   [wHeartBonusBombY], a
	ret
.onTimer19:
	ld   a, [wStaticPlLstId]			; Next player frame
	inc  a
	ld   [wStaticPlLstId], a
	ld   a, HEARTBONUS_OBJ_BOMBEXPL3	; Set bomb frame
	ld   [wHeartBonusBombLstId], a
	ld   a, [wStaticPlX]				; ExplosionX = PlX + $07
	add  $07
	ld   [wHeartBonusBombX], a
	ret
.onTimer28:;R
	ld   a, [wStaticPlLstId]			; Next player frame
	inc  a
	ld   [wStaticPlLstId], a
	ld   a, HEARTBONUS_OBJ_BOMBEXPL1	; Set bomb frame
	ld   [wHeartBonusBombLstId], a
	ld   a, [wStaticPlX]				; ExplosionX = PlX + $15
	add  $15
	ld   [wHeartBonusBombX], a
	ld   a, [wStaticPlY]				; ExplosionY = PlY + $03
	add  $03
	ld   [wHeartBonusBombY], a
	ret
.onTimer50:
	xor  a								; Hide explosion
	ld   [wHeartBonusBombLstId], a
	ld   a, $66							
	ld   [wStaticPlY], a
	ld   a, OBJ_HEARTBONUS_WARIO_BACKBOMBEXPL3
	ld   [wStaticPlLstId], a
	ret
.onTimer78:
	ld   a, SFX2_01						; Play miss SFX
	ld   [sSFX2Set], a
	ld   a, OBJ_HEARTBONUS_WARIO_BACKBOMBEXPL4
	ld   [wStaticPlLstId], a
	ret
; =============== HeartBonus_Game_Mode_Result ===============
; Submode $06: Player reacts to the round.
HeartBonus_Game_Mode_Result:
	; Do timing sequence
	; Remeber that the timer is set to $28 we went through the "timeout" mode,
	; which skips .plReact.
	ld   a, [wStaticPlAnimTimer]
	inc  a
	ld   [wStaticPlAnimTimer], a
	cp   a, $28
	jr   z, .plReact
	cp   a, $46
	jr   z, .plReact2
	cp   a, $78
	jr   z, .newRound
	ret
; =============== .plReact ===============
; Sets the new animation frame to react to money doubling/halved.
.plReact:
	ld   a, [wHeartBonusEnemyHit]
	cp   a, $00						; Did we hit the enemy?
	jr   nz, .setHitFrame			; If so, jump
.setMissFrame:
	ld   a, OBJ_STATIC_WARIO_LOST
	ld   [wStaticPlLstId], a
	ret
.setHitFrame:
	ld   a, OBJ_STATIC_WARIO_WON0
	ld   [wStaticPlLstId], a
	ret
; =============== .plReact2 ===============
; Sets the second frame for the reaction anim.
.plReact2:
	; Only the win animation has two frames
	ld   a, [wHeartBonusEnemyHit]
	cp   a, $00						; Did we hit the enemy?
	ret  z							; If not, return
	ld   a, OBJ_STATIC_WARIO_WON1
	ld   [wStaticPlLstId], a
	ret
; =============== .newRound ===============
; Increases the round number. 
; If we've gone through all five rounds, it switches to the result screen.
.newRound:
	ld   a, [wHeartBonusRoundNum]	; RoundNum++
	inc  a
	ld   [wHeartBonusRoundNum], a
	cp   a, $05						; Did we finish the fifth round?
	jr   z, .nextMode				; If so, switch to the result screen
	jp   HeartBonus_InitNextRound
.nextMode:
	ld   a, HEARTBONUS_MODE_INITRESULTS
	ld   [wHeartBonusMode], a
	ret
	
; =============== HeartBonus_InitResults ===============
; Mode $04: Initializes the results screen.
HeartBonus_InitResults:
	call StopLCDOperation
	call ClearWorkOAM
	ld   hl, BGRLE_HeartBonus_Results
	call DecompressBG_ToBGMap
	
	; The compressed tilemap contains baked-in the results for the hard difficulty.
	; If we want to display the ones for another difficulty, apply the patch tilemap.
	ld   a, [wHeartBonusDifficultySel]
	cp   a, HEARTBONUS_SEL_HARD
	call nz, HeartBonus_LoadBG_NormEasyResults
	
	call HeartBonus_InitCommon
	ld   [wHeartBonusHudBomb0LstId], a
	ld   [wHeartBonusHudBomb1LstId], a
	ld   [wHeartBonusHudBomb2LstId], a
	ld   [wHeartBonusHudBomb3LstId], a
	ld   [wHeartBonusHudBomb4LstId], a
	; We're going to update them (hopefully), so show them
	ld   a, $01
	ld   [wHeartBonusShowHudLivesHearts], a
	; Set player facing back at the center of the sign
	ld   a, OBJ_HEARTBONUS_WARIO_BACK
	ld   [wStaticPlLstId], a
	ld   a, $42
	ld   [wStaticPlX], a
	ld   a, $66
	ld   [wStaticPlY], a
	ld   a, LCDC_PRIORITY|LCDC_OBJENABLE|LCDC_WTILEMAP|LCDC_ENABLE
	ldh  [rLCDC], a
	ld   a, BGM_COINBONUS		; Reused for results screen
	ld   [sBGMSet], a
	ld   a, HEARTBONUS_MODE_RESULTS	; Next mode
	ld   [wHeartBonusMode], a
	ret
	
; =============== HeartBonus_LoadBG_NormEasyResults ===============
; Applies patch tilemaps to show the result screen for difficulties
; other than hard.
HeartBonus_LoadBG_NormEasyResults:
	ld   a, [wHeartBonusDifficultySel]
	cp   a, HEARTBONUS_SEL_EASY			; Easy difficulty?
	jr   z, .easy						; If so, jump
.mid:
	ld   de, BG_HeartBonus_MidTitle					
	call HeartBonus_WriteDifficultyBG
	ld   de, BG_HeartBonus_MidPrizes
	jr   HeartBonus_WritePrizesBG
.easy:
	ld   de, BG_HeartBonus_EasyTitle
	call HeartBonus_WriteDifficultyBG
	ld   de, BG_HeartBonus_EasyPrizes
	
; =============== HeartBonus_WritePrizesBG ===============
; Writes the tilemap for the prize list in the results screen.
; This includes the blank space between text.
HeartBonus_WritePrizesBG:
	; Needs to write a 4x9 area.
HBPRIZW EQU $04 ; Width of this tilemap
HBPRIZH EQU $09 ; Height of this tilemap

	ld   hl, vBGHeartBonusResultsPrizes	; HL = Location in the tilemap
	ld   b, HBPRIZH		; B = Height
.nextRow:
	ld   c, HBPRIZW		; C = Width
.nextCol:
	ld   a, [de]		; Copy over the tile id
	ldi  [hl], a
	inc  de				; DestPtr++
	dec  c				; Have we copied all tiles in the row?
	jr   nz, .nextCol	; If not, loop
	;--
	; Seek to the start of the next row
	push de
	ld   d, $00			; DE = $20-$04
	ld   e, BG_TILECOUNT_H-HBPRIZW
	add  hl, de			; Seek ahead
	pop  de
	;--
	dec  b				; RowsLeft--
	jr   nz, .nextRow
	ret
	
; =============== HeartBonus_WriteDifficultyBG ===============
; Writes the tilemap for the difficulty marker in the results screen.
; This is the letter shown on the top of the sign.
HeartBonus_WriteDifficultyBG:
	; Needs to write a 2x2 area.
HBDIFFW EQU $02 ; Width of this tilemap
HBDIFFH EQU $02 ; Height of this tilemap

	ld   hl, vBGHeartBonusResultsDifficulty	; HL = Location in the tilemap
	ld   b, HBDIFFH		; B = Height
.nextRow:
	ld   c, HBDIFFW		; C = Width
.nextCol:
	ld   a, [de]		; Copy over the tile id
	ldi  [hl], a
	inc  de				; DestPtr++
	dec  c				; Have we copied all tiles in the row?
	jr   nz, .nextCol	; If not, loop
	;--
	; Seek to the start of the next row
	push de
	ld   d, $00			; DE = $20-$02
	ld   e, BG_TILECOUNT_H-HBDIFFW
	add  hl, de			; Seek ahead
	pop  de
	;--
	dec  b				; RowsLeft--
	jr   nz, .nextRow
	ret
	
BG_HeartBonus_MidTitle: INCBIN "data/bg/heartbonus/midtitle.bin"
BG_HeartBonus_MidPrizes: INCBIN "data/bg/heartbonus/midprizes.bin"
BG_HeartBonus_EasyTitle: INCBIN "data/bg/heartbonus/easytitle.bin"
BG_HeartBonus_EasyPrizes: INCBIN "data/bg/heartbonus/easyprizes.bin"

; =============== HeartBonus_Results ===============
; Mode $05: Results screen and prize awarded.
HeartBonus_Results:
	call HeartBonus_WaitCtrlForReward
	
	; ($82-$33) frames after pressing A, start walking left to exit the bonus game.
	ld   a, [wHeartBonusResultsTimer]
	cp   a, $82							; Timer >= $82?
	jp   nc, HeartBonus_SwitchToExit	; If so, jump
	
	; As soon as rewards are given out, hide the flashing black line permanently.
	; and prevent execution from getting to .animFlashLine (otherwise it will reenable itself).
	cp   a, $35							; Timer >= $35?
	jr   nc, .hideResultFlash			; If so, jump
	
.animFlashLine:
	;
	; Animate the flashing line by repeatedly hiding and showing it
	; every few frames.
	;
	
	ld   a, [wHeartBonusModeTimer]		; AnimTimer++
	inc  a
	ld   [wHeartBonusModeTimer], a
	cp   a, $07							; AnimTimer == $07?
	jr   z, .showResultFlash			; If so, show the line
	cp   a, $0A							; Timer == $0A?
	ret  nz								; If not, return
	xor  a							 	; Otherwise, hide the line again
	ld   [wHeartBonusModeTimer], a		; and reset AnimTimer
	ld   [wHeartBonusShowResultFlash], a
	ret
.showResultFlash:
	ld   a, $01
	ld   [wHeartBonusShowResultFlash], a
	ret
.hideResultFlash:
	xor  a
	ld   [wHeartBonusShowResultFlash], a
	ret
	
; =============== HeartBonus_WaitCtrlForReward ===============
; Waits for the player to press A.
; Once that happens, the rewards in hearts/lives are given out.
HeartBonus_WaitCtrlForReward:
	ld   a, [wHeartBonusResultsTimer]
	; Timer is kept at $32 until pressing A
	cp   a, $32						; Timer == $32?
	jr   z, .waitCtrl				; If so, jump
	inc  a							; Timer++
	ld   [wHeartBonusResultsTimer], a
	
	; Give the rewards two frames after pressing A
	cp   a, $35						; Timer == $35?
	jr   z, .giveRewards			; If so, jump
	ret
.waitCtrl:
	ldh  a, [hJoyNewKeys]
	bit  KEYB_A, a					; Pressing A?
	ret  z							; If not, return
	ld   a, $33						; Advance the timer
	ld   [wHeartBonusResultsTimer], a
	ret
.giveRewards:
	; If we failed to hit anything, return immediately
	; This saves time and saves us a byte in each reward table.
	ld   a, [wHeartBonusHitCount]
	cp   a, $00
	ret  z
	
	;
	; Determine the rewards to give depending on difficulty and amount of hits.
	; For each difficulty, the rewards are defined through two different tables:
	; - One for the amount of lives awarded
	; - Another for the amount of hearts awarded
	;
	; Difficulties that don't award one of the two groups can avoid
	; defining one of the tables, saving space.
	; Both tables are indexed by the amount of hits, so they five entries long.
	;
	
	ld   a, [wHeartBonusDifficultySel]
	cp   a, HEARTBONUS_SEL_MED			; Medium difficulty?
	jr   z, .medium						; If so, jump
	cp   a, HEARTBONUS_SEL_EASY			; Easy difficulty?
	jr   z, .easy						; If so, jump
.hard:
	; The hard difficulty only awards lives, so we don't define an hearts reward table.
	ld   hl, HeartBonus_RewardLivesHardTbl
	call HeartBonus_IndexRewardTable		; A = Awarded lives
	ld   [wHeartBonusLivesChange], a		; Set the change count
	xor  a
	ld   [wHeartBonusHeartsChange], a
	jr   HeartBonus_UpdateHeartsCount
.medium:
	ld   hl, HeartBonus_RewardLivesMedTbl
	call HeartBonus_IndexRewardTable
	ld   [wHeartBonusLivesChange], a
	ld   hl, HeartBonus_RewardHeartsMedTbl
	call HeartBonus_IndexRewardTable
	ld   [wHeartBonusHeartsChange], a
	jr   HeartBonus_UpdateHeartsCount
.easy:
	ld   hl, HeartBonus_RewardLivesEasyTbl
	call HeartBonus_IndexRewardTable
	ld   [wHeartBonusLivesChange], a
	ld   hl, HeartBonus_RewardHeartsEasyTbl
	call HeartBonus_IndexRewardTable
	ld   [wHeartBonusHeartsChange], a
	
; =============== CoinBonus_UpdateCoinCount ===============
; Adds the specified amount of hearts.
HeartBonus_UpdateHeartsCount:

	;
	; Determine the sound effect to play, depending on whether
	; hearts of lives were awarded.
	;
	ld   a, [wHeartBonusHeartsChange]
	cp   a, $00				; Awarded hearts?
	jr   z, .chkLivesSFX	; If not, skip
.playHeartSFX:
	ld   a, SFX1_04			; Play hearts SFX
	ld   [sSFX1Set], a
	jr   .setHeartCount		;--
.chkLivesSFX:
	; [POI] If we get here, it's impossible for wHeartBonusLivesChange to be $00,
	;       since we never get here when hitting 0 enemies.
	;       Was this always the case though?
	ld   a, [wHeartBonusLivesChange]
	cp   a, $00				; Awarded lives?
	jr   z, .setHeartCount	; If not, skip
.playLivesSFX
	ld   a, SFX1_08			; Play lives SFX
	ld   [sSFX1Set], a
	
.setHeartCount:
	;--
	; sHearts += wHeartBonusHeartsChange
	ld   a, [wHeartBonusHeartsChange]	; B = HeartsToAdd
	ld   b, a
	ld   a, [sHearts]					; A = CurHearts
	add  b								; A += B
	daa
	ld   [sHearts], a
	
	; If we overflowed, also add an extra life
	jr   nc, .setLivesCount
	ld   a, [sLives]					; sLives++
	add  $01
	daa
	ld   [sLives], a
	jr   nc, .setLivesCount
	;--
.forceMaxVals:
	ld   a, $99
	ld   [sLives], a
	ld   [sHearts], a
	ret
.setLivesCount:
	;--
	; sLives += wHeartBonusLivesChange
	ld   a, [wHeartBonusLivesChange]	; B = LivesToAdd
	ld   b, a
	ld   a, [sLives]					; A = CurLives
	add  b								; A += B
	daa
	ld   [sLives], a
	; If we overflowed the lives counter, force it back to 99 lives.
	jr   c, .forceMaxVals
	;--
	ret
	
HeartBonus_RewardLivesHardTbl: 
	db $03
	db $05
	db $07
	db $10
	db $50
HeartBonus_RewardLivesMedTbl:
	db $00
	db $00
	db $01
	db $02
	db $03
HeartBonus_RewardHeartsMedTbl: 
	db $50
	db $70
	db $00
	db $00
	db $00
HeartBonus_RewardLivesEasyTbl:
	db $00
	db $00
	db $00
	db $00
	db $01
HeartBonus_RewardHeartsEasyTbl:
	db $01
	db $10
	db $50
	db $70
	db $00
	
; =============== HeartBonus_IndexRewardTable ===============
; Indexes the specified rewards table, based on the enemies hit.
; IN
; - HL: Ptr to reward table
; OUT
; - A: Indexed result (either lives or hearts awarded)
HeartBonus_IndexRewardTable:
	; Since we never get here when hitting no enemies,
	; we can save a byte from all of the tables, using (HitCount-1).
	ld   b, $00						; BC = HitCount - 1
	ld   a, [wHeartBonusHitCount]
	ld   c, a
	dec  c
	add  hl, bc						; Offset the table by BC
	ld   a, [hl]					; Read out the indexed value
	ret
	
; =============== HeartBonus_Exit ===============
; Makes Wario walk to the left, to off-screen.
; After that, the Bonus Game task ends
HeartBonus_Exit:
	ld   a, STATIC_OBJLST_XFLIP		; Face left
	ld   [wStaticPlFlags], a
	;
	; Move left at 1px/frame until we're enough off-screen.
	;
	ld   a, [wStaticPlX]		; Move left 1px
	dec  a
	ld   [wStaticPlX], a
	cp   a, $D0					; Player X == $D0?
	jp   nz, Static_Pl_WalkAnim	; If not, animate the walk
.end:
	;--
	; Tell the Course Clear screen that the bonus game is over.
	; This will cause the Treasure Room to start.
	ld   a, $01					
	ld   [sCourseClrBonusEnd], a
	xor  a
	ld   [wHeartBonusMode], a
	ret

GFXRLE_HeartBonus: INCBIN "data/gfx/heartbonus.rlc"
;--
L1E6A4A: db $00;X
L1E6A4B: db $00;X
L1E6A4C: db $00;X
L1E6A4D: db $00;X
L1E6A4E: db $00;X
L1E6A4F: db $00;X
;--
BGRLE_HeartBonus_Menu: INCBIN "data/bg/heartbonus/menu.rls"
BGRLE_HeartBonus_Game: INCBIN "data/bg/heartbonus/game.rls"
BGRLE_HeartBonus_Results: INCBIN "data/bg/heartbonus/results.rls"

; =============== CoinBonus_Do ===============
; Code structure looks very similar to the Title Screen code -- likely the same programmer.
CoinBonus_Do:
	ld   a, $A0						; Static_WriteOBJLst uses another variable for this purpose				
	ld   [sWorkOAMPos], a
	
	xor  a
	ld   [wCoinBonusBucketFrameSet], a
	ld   [wCoinBonusRoundBGChg], a
	call .main
	jp   CoinBonus_WriteOBJ
.main:
	; Do the mode switch
	ld   a, [wCoinBonusMode]
	rst  $28
	dw CoinBonus_Init
	dw CoinBonus_Main
	dw CoinBonus_Exit
; =============== CoinBonus_Init ===============
; Initializes the coin bonus game.
CoinBonus_Init:
	; Prepare VRAM for this
	call StopLCDOperation
	call ClearBGMapEx
	call ClearWorkOAM
	ld   hl, GFXRLE_CoinBonus
	call DecompressGFXStub
	call LoadGFX_BonusGame_WarioPowerHat
	ld   hl, BGRLE_CoinBonus
	call DecompressBG_ToBGMap
	call CoinBonus_InitVars
	
	ld   a, LCDC_ENABLE|LCDC_WTILEMAP|LCDC_OBJENABLE|LCDC_PRIORITY
	ldh  [rLCDC], a
	ld   a, BGM_COINBONUS
	ld   [sBGMSet], a
	ld   a, COINBONUS_MODE_MAIN
	ld   [wCoinBonusMode], a
	ret
	
; =============== CoinBonus_InitVars ===============
CoinBonus_InitVars:
	xor  a
	ld   [wCoinBonusAct], a
	ld   [wCoinBonusRound], a
	ld   [wHeartBonusTileAnim], a
	ld   [wStaticPlLstId], a
	ldh  [rSCX], a
	ldh  [rSCY], a
	ldh  [rWY], a
	; Set initial player coords
	ld   a, $E0						; Off-screen left	
	ld   [wStaticPlX], a
	ld   a, $7A						; Above the ground (8px wall + 8px status bar from below)
	ld   [wStaticPlY], a
	ld   a, $1D						; Set OBJ palette
	ldh  [rOBP0], a
	ld   a, $E1						; Set BG + OBJ1 Palette
	ldh  [rBGP], a
	ldh  [rOBP1], a
; =============== CoinBonus_InitNextTurn ===============
; Sets up the next turn for the bonus game.
CoinBonus_InitNextTurn:
	xor  a
	ld   [wStaticPlAnimTimer], a
	ld   [wCoinBonusModeTimer], a
	ld   [wCoinBonusItemLstId], a
	ld   [wStaticPlFlags], a
	ld   [wCoinBonusItemType], a
	ld   a, COINBONUS_PLPOS_MID		; Start between buckets			
	ld   [wCoinBonusPlayerPos], a
	
	;
	; Determine at random which bucket contains the moneybag,
	; and which contains the 10-ton.
	;
	; Curiously it does not use the standard random function,
	; and just goes off the raw divider register... and actually
	; saves the generated item types in two separate addresses.
	;
	ldh  a, [rDIV]				; A = Random number
	bit  0, a					; A % 2 == 0?
	jr   z, .moneyR				; If so, place the moneybag on the right
.moneyL:
	xor  a ; COINBONUS_ITEM_10TON
	ld   [wCoinBonusItemTypeR], a
	ld   a, COINBONUS_ITEM_MONEYBAG
	ld   [wCoinBonusItemTypeL], a
	ret
.moneyR:
	xor  a ; COINBONUS_ITEM_10TON
	ld   [wCoinBonusItemTypeL], a
	ld   a, COINBONUS_ITEM_MONEYBAG
	ld   [wCoinBonusItemTypeR], a
	ret
	
; =============== CoinBonus_Main ===============
CoinBonus_Main:
	ld   a, [wCoinBonusAct]
	rst  $28
	dw CoinBonus_Mode_MoveRight
	dw CoinBonus_Mode_Idle
	dw CoinBonus_Mode_MoveLeft
	dw CoinBonus_Mode_Action
	dw CoinBonus_Mode_Pull
	dw CoinBonus_Mode_DropItem
	dw CoinBonus_Mode_ItemBounce
	dw CoinBonus_Mode_MoveCenter
	dw CoinBonus_Mode_Result
; =============== CoinBonus_GetPlXTarget ===============
; This subroutine gets the target X position we're walking to,
; depending on the currently specified position (wCoinBonusPlayerPos).
;
; Used specifically for the wCoinBonusAct modes where the player walks, except
; when moving left to off-screen from the exit position (which is handled in CoinBonus_Exit).
; OUT
; - B: Target X position for the player to stop walking
CoinBonus_GetPlXTarget:
	; Index the target pos from the table
	ld   a, [wCoinBonusPlayerPos]	; DE = Player position ID
	ld   d, $00
	ld   e, a
	ld   hl, .posTable				; HL = Table with X positions
	add  hl, de						; Index the table
	ld   a, [hl]					; B = Target X pos
	ld   b, a
	ret
.posTable: 
	db COINBONUS_PLXPOS_EXIT  ; $0C
	db COINBONUS_PLXPOS_LEFT  ; $2F
	db COINBONUS_PLXPOS_MID   ; $4C
	db COINBONUS_PLXPOS_RIGHT ; $67
	
; =============== CoinBonus_Mode_MoveRight ===============
; Mode $00: Walking right until reaching the target.
CoinBonus_Mode_MoveRight:
	call CoinBonus_GetPlXTarget		; B = Target pos
	xor  a
	ld   [wStaticPlFlags], a		; Face right
	ld   a, [wStaticPlX]			; Move right 1px
	inc  a
	ld   [wStaticPlX], a
	cp   a, b						; Reached the target pos?
	jp   nz, Static_Pl_WalkAnim		; If not, contine the walk anim
	; Otherwise, stop walking
; =============== CoinBonus_SwitchToIdle ===============
CoinBonus_SwitchToIdle:
	xor  a
	ld   [wStaticPlAnimTimer], a
	ld   [wCoinBonusModeTimer], a
	ld   [wStaticPlFlags], a
	ld   a, OBJ_STATIC_WARIO_IDLEDIAG
	ld   [wStaticPlLstId], a
	ld   a, COINBONUS_RTN_IDLE
	ld   [wCoinBonusAct], a
	ret
; =============== CoinBonus_Mode_MoveLeft ===============
; Mode $02: Walking left until reaching the target.
CoinBonus_Mode_MoveLeft:
	call CoinBonus_GetPlXTarget		; B = Target pos
	ld   a, STATIC_OBJLST_XFLIP		; Face left
	ld   [wStaticPlFlags], a
	ld   a, [wStaticPlX]			; Move left 1px
	dec  a
	ld   [wStaticPlX], a
	cp   a, b						; Reached the target pos?
	jp   nz, Static_Pl_WalkAnim		; If not, contine the walk anim
	jr   CoinBonus_SwitchToIdle
	
; =============== CoinBonus_Mode_Idle ===============
; Mode $01: When player input is accepted.
CoinBonus_Mode_Idle:
	;
	; Handle player idle animation (always facing right, and turning the head).
	; Switch between frames every $32 frames, and play SFX when switching.
	;
	ld   a, [wStaticPlAnimTimer]	; Timer++
	inc  a
	ld   [wStaticPlAnimTimer], a
	cp   a, $32						; Timer == $32?
	jr   z, .idleL					; If so, jump
	cp   a, $64						; Timer == $64?
	jr   z, .idleR					; If so, jump
	jr   .doCtrl
.idleL:
	ld   a, SFX1_19
	ld   [sSFX1Set], a
	ld   a, OBJ_COINBONUS_WARIO_IDLEDIAGBACK	; Head back
	ld   [wStaticPlLstId], a
	jr   .doCtrl
.idleR:
	ld   a, SFX1_18
	ld   [sSFX1Set], a
	xor  a
	ld   [wStaticPlAnimTimer], a	
	ld   a, OBJ_STATIC_WARIO_IDLEDIAG		; Head normal
	ld   [wStaticPlLstId], a
.doCtrl:
	;
	; Handle controls
	;
	ldh  a, [hJoyNewKeys]
	bit  KEYB_A, a			; Pressing A?
	jr   nz, .tryAction		; If so, try 
	bit  KEYB_RIGHT, a
	jr   nz, .tryMoveR
	bit  KEYB_LEFT, a
	jr   nz, .tryMoveL
	ret
.tryAction:
	; Switch to the mode that tries to perform the action at the current position
	xor  a
	ld   [wStaticPlAnimTimer], a
	ld   a, COINBONUS_RTN_ACTION
	ld   [wCoinBonusAct], a
	ret
.tryMoveR:
	; Can't move right from the rightmost position
	ld   a, [wCoinBonusPlayerPos]
	cp   a, COINBONUS_PLPOS_RIGHT
	ret  z
	
	; Otherwise, trigger right movement
	inc  a
	ld   [wCoinBonusPlayerPos], a
	xor  a
	ld   [wStaticPlAnimTimer], a
	ld   [wCoinBonusAct], a				; COINBONUS_RTN_MOVER
	ret
.tryMoveL:
	; If we're moving left at the leftmost position, we're exiting the bonus game early
	ld   a, [wCoinBonusPlayerPos]
	cp   a, COINBONUS_PLPOS_EXIT		; Pos == $00?
	jr   z, CoinBonus_SwitchToExit		; If so, jump
	
	; Otherwise, trigger left movement
	dec  a
	ld   [wCoinBonusPlayerPos], a
	xor  a
	ld   [wStaticPlAnimTimer], a
	ld   a, COINBONUS_RTN_MOVEL
	ld   [wCoinBonusAct], a
	ret
	
; =============== CoinBonus_SwitchToExit ===============
CoinBonus_SwitchToExit:
	ld   a, BGMACT_FADEOUT
	ld   [sBGMActSet], a
	xor  a
	ld   [wStaticPlAnimTimer], a
	jp   CoinBonus_Exit
; =============== CoinBonus_Mode_Action ===============
; Mode $03: After pressing A.
CoinBonus_Mode_Action:
	; Which position are we on?
	ld   a, [wCoinBonusPlayerPos]
	cp   a, COINBONUS_PLPOS_EXIT	; Leftmost?
	jr   z, CoinBonus_SwitchToExit	; If so, exit to the left
	cp   a, COINBONUS_PLPOS_MID		; Between buckets?
	jp   z, CoinBonus_SwitchToIdle	; If so, don't do anything
	cp   a, COINBONUS_PLPOS_LEFT	; On the left bucket?
	jr   z, .leftBucket				; If so, pull it
									; Otherwise, we're on the right bucket
	
	;
	; Determine X location of the dropped item
	;
.rightBucket:
	ld   a, COINBONUS_PLXPOS_RIGHT+$04	; A = X location on right bucket
	jr   .setX
.leftBucket:
	ld   a, COINBONUS_PLXPOS_LEFT+$04	; A = X location on left bucket
.setX:
	ld   [wCoinBonusItemX], a			; Save var
	
	;
	; Determine which item we're spawning, depending on the bucket we selected.
	; This could have been made shorter by using a single value instead of two, but what do I know.
	;
	ld   a, [wCoinBonusPlayerPos]
	cp   a, COINBONUS_PLPOS_RIGHT	; Are we on the right?
	jr   z, .useItemR				; If so, jump
.useItemL:
	ld   a, [wCoinBonusItemTypeL]
	and  a							; Is the item a moneybag (!= 0)
	jr   z, .set10Ton				; If not, jump
	jr   .setMoneybag
.useItemR:
	ld   a, [wCoinBonusItemTypeR]
	and  a							; Is the item a moneybag (!= 0)
	jr   z, .set10Ton				; If not, jump
.setMoneybag:
	; Takes the same value as the OBJLst for convenience.
	ld   a, COINBONUS_OBJ_ITEM_MONEYBAG	; A = Item ID (more or less)
	jr   .setItem
.set10Ton:
	ld   a, COINBONUS_OBJ_ITEM_10TON	; A = Item ID (more or less)
.setItem:
	ld   [wCoinBonusItemType], a	; Save it
	
	ld   a, SFX1_03					; Play grab rope SFX
	ld   [sSFX1Set], a
	ld   a, $04						; Next mode
	ld   [wCoinBonusAct], a
	ret
	
; =============== CoinBonus_Mode_Pull ===============
; Mode $04: Animation sequence when pulling the rope.
CoinBonus_Mode_Pull:
	ld   a, [wStaticPlAnimTimer]	; Timer++
	inc  a
	ld   [wStaticPlAnimTimer], a
	
	cp   a, $14
	jr   z, .grabRope
	cp   a, $3C
	jr   z, .pullRope
	cp   a, $5A
	jr   z, .releaseRope
	cp   a, $6E
	jr   z, .showItem
	ret
.grabRope:
	ld   a, SFX1_18
	ld   [sSFX1Set], a
	ld   a, OBJ_COINBONUS_WARIO_PULL0
	ld   [wStaticPlLstId], a
	ret
.pullRope:
	ld   a, SFX1_11
	ld   [sSFX1Set], a
	ld   a, OBJ_COINBONUS_WARIO_PULL1
	ld   [wStaticPlLstId], a
	ld   a, COINBONUS_BUCKET_PULL		; Request upside down bucket
	ld   [wCoinBonusBucketFrameSet], a
	ret
.releaseRope:
	ld   a, OBJ_STATIC_WARIO_IDLEDIAG
	ld   [wStaticPlLstId], a
	ret
.showItem:
	; Start drawing the item
	ld   a, SFX1_29					; Play drop SFX
	ld   [sSFX1Set], a
	xor  a							; Clear anim frame
	ld   [wStaticPlAnimTimer], a
	; Make item visible, by changing the frame from COINBONUS_OBJ_ITEM_NONE
	; to what we've previously set in wCoinBonusItemType
	ld   a, [wCoinBonusItemType]	; Make visibleCopy over frame id
	ld   [wCoinBonusItemLstId], a
	ld   a, $52						; Set Y pos to be near the bucket
	ld   [wCoinBonusItemY], a
	ld   a, COINBONUS_RTN_DROPITEM
	ld   [wCoinBonusAct], a
	ret
	
; =============== CoinBonus_Mode_DropItem ===============
; Mode $05: Item falls down and crushes player.
CoinBonus_Mode_DropItem:
	; Make the item fall down until it hits the player
	ld   a, [wCoinBonusItemY]
	cp   a, $6E					; Y >= $6E?
	jr   nc, .plHit			; If so, we hit the player
	inc  a						; Y += 2
	inc  a
	ld   [wCoinBonusItemY], a
	ret
.plHit:
	ld   a, OBJ_COINBONUS_WARIO_CRUSHED
	ld   [wStaticPlLstId], a
	;
	; The moneybag bounces off the player, while the 10-ton doesn't move anymore.
	;
	ld   a, [wCoinBonusItemType]
	cp   a, COINBONUS_OBJ_ITEM_MONEYBAG		; Is the item a moneybag?					
	jr   z, .bounceItem						; If so, jump
	
	ld   a, SFX1_02					; Bad choice sfx
	ld   [sSFX1Set], a
	ld   a, $7B						; Force back to right above the player
	ld   [wCoinBonusItemY], a
	jr   CoinBonus_SwitchToMoveCenter	; Skip the bounce
.bounceItem:
	ld   a, SFX1_24					; Good choice sfx
	ld   [sSFX1Set], a
	ld   a, COINBONUS_RTN_BOUNCE	; Do bounce
	ld   [wCoinBonusAct], a
	ret
	
; =============== CoinBonus_Mode_ItemBounce ===============
; Mode $06: Makes the item bounce (only the moneybag calls this).
CoinBonus_Mode_ItemBounce:
	; Handle the bounce through a table of Y positions (not offsets).
	; When the index goes over the end of the table, we've finished going through the path.
	
	ld   a, [wCoinBonusModeTimer]	; A = Index
	cp   a, CoinBonus_MoneybagBounceYPath.end-CoinBonus_MoneybagBounceYPath	; Is it out of range?
	jr   z, CoinBonus_SwitchToMoveCenter					; If so, we're done
	
.followPath:
	;
	; Vertical movement
	;

	; Increase index
	ld   c, a						; C = Index
	inc  a							
	ld   [wCoinBonusModeTimer], a	; Index++
	; Index the path table
	ld   hl, CoinBonus_MoneybagBounceYPath	; HL = Y path table 
	ld   b, $00
	add  hl, bc						; Offset it
	; Update the Y position
	ld   a, [hl]					; A = New Y pos 
	ld   [wCoinBonusItemY], a		; Set it
	
	;
	; Horizontal movement (fixed 1px/frame)
	;
	
	; Move the item always to the center of the screen
	ld   a, [wCoinBonusPlayerPos]
	cp   a, COINBONUS_PLPOS_LEFT	; Is it from the left bucket?				
	jr   z, .moveR					; If so, move the moneybag right
.moveL:
	ld   a, [wCoinBonusItemX]		; Move left 1px
	dec  a
	ld   [wCoinBonusItemX], a
	ret
.moveR:
	ld   a, [wCoinBonusItemX]		; Move right 1px
	inc  a
	ld   [wCoinBonusItemX], a
	ret
; =============== CoinBonus_Mode_ItemBounce ===============
CoinBonus_SwitchToMoveCenter:
	xor  a
	ld   [wCoinBonusModeTimer], a
	ld   a, COINBONUS_RTN_MOVEC
	ld   [wCoinBonusAct], a
	ret
; =============== CoinBonus_MoneybagBounceYPath ===============
CoinBonus_MoneybagBounceYPath: 
	db $6C,$6A,$69,$68,$67,$66,$66,$65,$65,$65,$66,$66,$67,$68,$69,$6A
	db $6B,$6C,$6E,$70,$72,$74,$76,$78,$7A,$7C,$7E,$80,$82
.end:

; =============== CoinBonus_Mode_MoveCenter ===============
; Mode $07: The player walks to the center of the screen.
CoinBonus_Mode_MoveCenter:
	; 
	; Wait $64 frames before starting to walk.
	;
	ld   a, [wCoinBonusModeTimer]
	cp   a, $64						; Timer == $64?
	jr   z, .walk					; If so, jump
	inc  a							; Timer++
	ld   [wCoinBonusModeTimer], a
.chkSFXBad:
	;
	; If we got a 10ton, play a SFX after $50 frames.
	; This is just before we're starting to walk.
	;
	cp   a, $50						; Timer != $50?
	ret  nz							; If so, jump
	xor  a
	ld   [wCoinBonusItemLstId], a
	ld   a, [wCoinBonusItemType]
	cp   a, COINBONUS_OBJ_ITEM_MONEYBAG	; Is this a moneybag?
	ret  z								; If so, return
	ld   a, SFX2_01
	ld   [sSFX2Set], a
	ret
.walk:
	;
	; Determine where the center is, depending on the current location.
	; Then move towards it.
	;
	ld   a, [wCoinBonusPlayerPos]
	cp   a, COINBONUS_PLPOS_RIGHT		; Are we on the right bucket?
	jr   z, .moveL						; If so, move left
.moveR:									; Otherwise, move right
	xor  a								; Face right
	ld   [wStaticPlFlags], a
	ld   a, [wStaticPlX]				; PlayerX--
	inc  a
	ld   [wStaticPlX], a
	cp   a, COINBONUS_PLXPOS_MID		; Reached the target X pos?
	jp   z, .nextMode					; If so, we're done moving
	jp   Static_Pl_WalkAnim
.moveL:
	ld   a, STATIC_OBJLST_XFLIP			; Face left
	ld   [wStaticPlFlags], a
	ld   a, [wStaticPlX]				; PlayerX++
	dec  a
	ld   [wStaticPlX], a
	cp   a, COINBONUS_PLXPOS_MID		; Reached the target X pos?
	jp   nz, Static_Pl_WalkAnim			; If not, continue moving
.nextMode:
	;
	; Switch to the result mode
	;
	xor  a
	ld   [wCoinBonusModeTimer], a
	ld   a, OBJ_STATIC_WARIO_FRONT
	ld   [wStaticPlLstId], a
	ld   a, COINBONUS_RTN_RESULT
	ld   [wCoinBonusAct], a
	ret
	
; =============== CoinBonus_Mode_Result ===============
; Mode $08: Coins are doubled or halved, then Wario reacts to it.
CoinBonus_Mode_Result:
	;
	; Wait for $37 frames, then slowly update the coin count 1 by 1.
	; Until that finishes, we won't be increasing the timer.
	;
	ld   a, [wStaticPlAnimTimer]
	cp   a, $37							; Timer == $37?
	jp   z, BonusGame_UpdateCoinCount	; If so, jump
	inc  a								; Timer++
	ld   [wStaticPlAnimTimer], a
	; Right before doing that, set the amount of coins to add or remove
	cp   a, $36										
	jr   z, .setCoinChange
	
	;
	; When we get here, the coin count is fully updated.
	; We can now play the "react" anim.
	;
	cp   a, $5A
	jr   z, .plReact				
	cp   a, $78
	jr   z, .plReact2					
	cp   a, $AA
	jr   z, .incRound
	cp   a, $AB
	jr   z, .newTurn
	ret
; =============== .plReact ===============
; Sets the new animation frame to react to money doubling/halved.
.plReact:
	ld   a, [wCoinBonusItemType]
	cp   a, COINBONUS_OBJ_ITEM_MONEYBAG		; Is the item a moneybag?
	jr   z, .goodItem						; If so, our money got doubled
.badItem:
	ld   a, SFX1_1D							; Sad SFX
	ld   [sSFX1Set], a
	ld   a, OBJ_STATIC_WARIO_LOST
	ld   [wStaticPlLstId], a
	ret
.goodItem:
	ld   a, OBJ_STATIC_WARIO_WON0
	ld   [wStaticPlLstId], a
	ret
; =============== .plReact2 ===============
; Sets the second frame for the reaction anim.
.plReact2:
	; Only the win animation has two frames
	ld   a, [wCoinBonusItemType]
	cp   a, COINBONUS_OBJ_ITEM_MONEYBAG		; Is the item a moneybag?
	ret  nz									; If not, return
	ld   a, OBJ_STATIC_WARIO_WON1
	ld   [wStaticPlLstId], a
	ret
; =============== .incRound ===============
; Increases the round count, requesting a GFX update.
; If this is our last round, it will end the bonus game.
.incRound:
	ld   a, [wCoinBonusRound]			; RoundNum++
	inc  a
	ld   [wCoinBonusRound], a
	cp   a, $03							; Did we finish the third round?
	jp   z, CoinBonus_SwitchToExit		; If so, automatically walk to the exit
	ld   a, COINBONUS_BUCKET_NORMAL		; Reset normal bucket tilemap
	ld   [wCoinBonusBucketFrameSet], a
	ld   [wCoinBonusRoundBGChg], a
	ret
; =============== .newTurn ===============
; Sets up the new turn.
.newTurn:
	call CoinBonus_InitNextTurn
	jp   CoinBonus_SwitchToIdle
	
; =============== .setCoinChange ===============
; Determines the amount of coins to add or remove.
.setCoinChange:
	;
	; When getting the moneybag the coins double.
	; When getting the 10-ton the coins are halved.
	;
	
	ld   a, [wCoinBonusItemType]
	cp   a, COINBONUS_OBJ_ITEM_10TON	; Got a 10-ton?
	jr   z, .setRemCoins				; If so, jump
.setAddCoins:
	;
	; Double the coins by adding the current coin count.
	; wBonusGameCoinChange = sLevelCoins
	;
	ld   a, [sLevelCoins_High]
	ld   [wBonusGameCoinChange_High], a
	ld   a, [sLevelCoins_Low]
	ld   [wBonusGameCoinChange_Low], a
	ret
.setRemCoins:
	;
	; Set half of the coin count, rounding up the value.
	; wBonusGameCoinChange = sLevelCoins / 2
	;
	;####
	ld   a, [sLevelCoins_High]	; HL = sLevelCoins
	ld   h, a
	ld   a, [sLevelCoins_Low]
	ld   l, a
	
	;
	; First of all, split the three digits of the BCD number in separate registers.
	; This simplifies handling the division.
	;
	
	; C = Lowest digit (sLevelCoins_Low, low nybble)
	and  a, $0F		; C = sLevelCoins_Low & $0F			
	ld   c, a				
	
	; B = Tens digit (sLevelCoins_Low, high nybble)
	ld   a, l		; B = sLevelCoins_Low >> 4			
	swap a
	and  a, $0F
	ld   b, a
	
	; Since the upper nybble of the high byte is unused, H is already in a good format.
	
	;
	; Divide all three digits by 2, adding the remainder to the lower digits.
	;
	
	; Divide the hundreds by 2.
	srl  h				; H = H/2
	; If we have a remainder, add 10 to the "tens" digit.
	; This won't be a problem when re-merging the digits, since the highest
	; value it can possibly get to is 19, which divided by 2 doesn't fill the upper nybble.
	jr   nc, .divMid	; Is there a remainder? If not, skip this.
	ld   a, b			; B += 10
	add  $0A
	ld   b, a
	
	; Divide the tens by 2
.divMid:
	srl  b				; B = B/2
	jr   nc, .divLow	; Is there a remainder? If not, skip this
	ld   a, c			; C += 10
	add  $0A
	ld   c, a
	
	; Divide the last digit by 2
	; The remainder is kept in the carry for a while, until we get to round up the division.
.divLow:
	srl  c				; B = B/2
	
	;
	; Merge the lowest and tens digits back
	;
	ld   a, b			; A = (B << 4) + C
	swap a
	add  c
	ld   [wBonusGameCoinChange_Low], a	; Save low byte
	ld   a, h						; Save high byte
	ld   [wBonusGameCoinChange_High], a
	;####
	
	;
	; Round up the division 
	;
	ld   a, [sLevelCoins_Low]
	bit  0, a					; Is coin count odd?
	ret  z						; If not, return
	ld   a, [wBonusGameCoinChange_Low]
	add  $01					; If so, remove another coin
	daa							; Adjust for BCD
	ld   [wBonusGameCoinChange_Low], a
	; If we increased 99 to 100, carry over to the high digit
	ret  nc						
	ld   a, [wBonusGameCoinChange_High]
	inc  a
	ld   [wBonusGameCoinChange_High], a
	ret
	
; =============== BonusGame_UpdateCoinCount ===============
; Adds or removes the specified amount of coins, one by one every frame.
; Note that this subroutine expects the player to *not* do the walking anim,
; since it reuses wStaticPlAnimTimer for a different purpose.
BonusGame_UpdateCoinCount:
	;
	; When the aren't any more coins to add/remove, continue to the react anim.
	;
	ld   a, [wBonusGameCoinChange_Low]	; B = Low byte
	ld   b, a
	ld   a, [wBonusGameCoinChange_High]	; A = High byte
	or   a, b						; A != 0 || B != 0?
	jr   nz, .decCoinChange			; If so, we aren't done yet
.end:
	; This $38 value is large enough to cater to both HeartBonus_Menu_Mode_Select
	; and CoinBonus_Mode_Result.
	; Technically it's this large for CoinBonus_Mode_Result, since its timer is $37
	; while we're changing the coin count.
	ld   a, $38						; Allow the react anim to start
	ld   [wStaticPlAnimTimer], a
	ret
.decCoinChange:
	ld   a, SFX2_02					; Play coin SFX
	ld   [sSFX2Set], a
	;--
	; wBonusGameCoinChange--
	ld   a, [wBonusGameCoinChange_Low]	; Decrease low byte
	sub  a, $01
	daa								; Adjust for BCD
	jr   nc, .noDecHigh				; Underflowed the low byte? If not, skip.
	ld   a, [wBonusGameCoinChange_High]	; Decrease high byte
	dec  a
	ld   [wBonusGameCoinChange_High], a
	ld   a, $99
.noDecHigh:
	ld   [wBonusGameCoinChange_Low], a
	;--
	;
	; Determine if we're adding or removing a coin
	;
.chkChangeType:
	ld   a, [wCoinBonusItemType]
	cp   a, COINBONUS_OBJ_ITEM_10TON	; Did we get hit by a 10-ton?
	jr   z, .remCoin					; If so, remove a coin
.addCoin:
	;--
	; sLevelCoins++
	ld   a, [sLevelCoins_Low]	; Increase low byte		
	add  $01
	daa
	ld   [sLevelCoins_Low], a
	jr   nc, .noIncHigh			; Did we overflow? If so, increase the high byte too.
	ld   a, [sLevelCoins_High]	; Increase high byte.
	inc  a
	ld   [sLevelCoins_High], a
.noIncHigh:
	ld   a, [sLevelCoins_High]
	;--
	; Prevent from going past 999.
	cp   a, $0A					; CoinCount >= 1000?
	ret  c						; If not, return
	ld   a, $09					; Otherwise, force it back to 999
	ld   [sLevelCoins_High], a
	ld   a, $99
	ld   [sLevelCoins_Low], a
	jr   .end					; And end the coin update early, to avoid extra coin SFX
	
.remCoin:
	;--
	; sLevelCoins--
	; Note that there's no failsafe from removing more coins that we have
	; (the game crashes if the count goes negative)
	ld   a, [sLevelCoins_Low]	; Decrease low byte
	sub  a, $01
	daa
	ld   [sLevelCoins_Low], a
	ret  nc						; Did we underflow? If not, return
	ld   a, [sLevelCoins_High]	; Otherwise, decrease high byte as well
	dec  a
	ld   [sLevelCoins_High], a
	ld   a, $99					; Set low byte to 99 coins
	ld   [sLevelCoins_Low], a
	;--
	ret
	
; =============== CoinBonus_Exit ===============
; Makes Wario walk to the left, to off-screen.
; After that, the Bonus Game task ends
CoinBonus_Exit:
	ld   a, COINBONUS_MODE_EXIT		; Prevent changes
	ld   [wCoinBonusMode], a
	ld   a, STATIC_OBJLST_XFLIP		; Face left
	ld   [wStaticPlFlags], a
	
	;
	; Move left at 1px/frame until we're enough off-screen.
	;
	ld   a, [wStaticPlX]
	cp   a, $D8					; Player X == $D8?
	jr   z, .end				; If so, end the bonus game
	dec  a						; Otherwise, continue moving left
	ld   [wStaticPlX], a
	jp   Static_Pl_WalkAnim		; Animate the walk
.end:
	;--
	; Tell the Course Clear screen that the bonus game is over.
	; This will cause the Treasure Room to start.
	ld   a, $01						
	ld   [sCourseClrBonusEnd], a
	;--
	; [TCRF] Broken debug/test functionality still left in?
	;        The way it's laid out implies it may have originally used hJoyKeys, so if you held A when exiting the bonus game, it would restart.
	;        It doesn't work though, since setting sCourseClrBonusEnd forces the bonus game to end anyway.
	;        
	;        And the heart bonus game resets its mode anyway, without joypad checks.
	ldh  a, [hJoyNewKeys]
	bit  KEYB_A, a			; Pressing A? (1-frame window to pull off)
	ret  z					; If not, return
	xor  a					; If so, restart the bonus game
	ld   [wCoinBonusMode], a
	ret
	;--
	
GFXRLE_CoinBonus: INCBIN "data/gfx/coinbonus.rlc"
	mIncJunk "L1E7D61"
BGRLE_CoinBonus: INCBIN "data/bg/coinbonus/mainbg.rls"

; =============== END OF BANK ===============
	mIncJunk "L1E7EC1"
